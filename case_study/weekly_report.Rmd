---
title: "Emory Covid-19 Case Study Script"
author: "EpiRHandbook Team"
date: "13 August 2021"
output: 
     word_document: 
          keep_md: TRUE
params: 
     surveillance_date: 2021-06-30
---


# Introduction to this case study script

This is a an example R-markdown script which demonstrates how to create an 
automated outbreak situation report for COVID-19 in Fulton county, USA.  

- We demonstrate how to import, clean and analyse your data.  
- Analysis is organised by time, place and person.  
     - For the purpose of the case study we separate this by descriptive analysis
     and visualisation (normally this would be mixed together of course)  
     - Analysis is loosely based off the monthly [epidemiology reports](https://www.fultoncountyga.gov/covid-19/epidemiology-reports) 
     for Fulton county  
- Text within <! > will not show in your final document.  
     - The other parts such as slashes (///), dashes (-) and tildes (~) are just aesthetic
     - These comments are used to explain the code chunks.   
     - We refer to functions in curly brackets, e.g. {dplyr} and functions end in brackets, e.g. count()  
     - This comment will not show up when you knit the document.  
     - You can delete them if you want.  
- Feedback & suggestions are welcome at the [GitHub issues page](https://github.com/appliedepi/emory_training/issues)  
     - Alternatively email us at: [epirhandbook@gmail.com](mailto:epiRhandbook@gmail.com)  


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This comment will not show up when you knit the document.
A comment with a title with slashes indicates a name of a code chunk.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// setup \\\
--------------------------------------------------------------------------------

Several packages are required for different aspects of  analysis with *R*. 
You will need to install these before starting. 

We install and load packages using the {pacman} package. 

This might prove difficult if you have limited administrative rights for your 
computer. Making sure your IT-department gives you the correct access can save a 
lot of headache. 

See this handbook pages on the basics of installing packages and running R from 
network drives (company computers) for more detail. 

https://epirhandbook.com/r-basics.html#installation
https://epirhandbook.com/r-on-network-drives.html#r-on-network-drives
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r setup, include=FALSE}

# hide all code chunks in the output, but show errors 
     # nb. warnings and messages still shown
knitr::opts_chunk$set(echo = FALSE,  # hide all code chunks in output
                      error = TRUE   # show errors if they appear, but don't stop (produce the word doc)
                     )

# Ensures the package "pacman" is installed
if (!require("pacman")) {
     install.packages("pacman") }

# install (if necessary) and load packages to be used
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways 
  skimr,      # get overview of data
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  epikit,     # age_categories() function
  tidyverse,  # data management and visualization
  flextable,  # converting tables to pretty images
  sf,         # manage spatial data using a Simple Feature format
  scales      # define colour schemes for flextables 
)

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// define_current_week \\\
--------------------------------------------------------------------------------
Here we use the date you want to report on, defined in parameters above to create
a date object which we can use for filtering datasets and analysis. 

We also create a week object to make grouping data easier. In this scenario we 
have defined the week to start on Wednesdays as this is when Fulton County 
releases their reports (but you can choose any other day of the week too). 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r define_current_week}

# create a date object from the parameter
surveillance_date <- as.Date(params$surveillance_date)

# create an epiweek object from the date 
# floor_date rounds to the closest week here
surveillance_week <- floor_date(surveillance_date,
                          # round by weeks
                          unit = "week", 
                          # define week to start on Wednesday
                          week_start = 3)
```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// import \\\
--------------------------------------------------------------------------------

We use the {rio} package for importing our example data - it is very versatile 
and can read in most file types. 

We use the {here} package for defining the path to our file. This is important 
for sharing your script with others (by email or on Sharepoint) - if you used an
"absolute" path, they would need to update the script to match their computer. 

This way your whole R-project folder can be zipped up and moved somewhere else. 

For more details see: 
https://epirhandbook.com/import-and-export.html
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r import}

## TODO: at the end remove "case_study" from path - so that can be used within case_study.Rproj

# import the raw case data set 
# define the path using {here} then pass that to the {rio} import function 
# linelist_raw <- here("case_study", "data", 
#                      "covid_example_data", "covid_example_data.xlsx") %>% 
#      # specify the sheet to read using which (default is to read first sheet)
#      import(which = "in")

linelist_raw <- here("data", 
                     "covid_example_data", "covid_example_data.xlsx") %>% 
     # specify the sheet to read using which (default is to read first sheet)
     import(which = "in")


# import shapefile
  # for mapping and for extracting population counts for zipcodes
# shapefile <- read_sf(here("case_study", "data", 
#                      "covid_example_data", "covid_shapefile", "FultonCountyZipCodes.shp"))

shapefile <- read_sf(here("data", 
                     "covid_example_data", "covid_shapefile", "FultonCountyZipCodes.shp"))

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// browse_data \\\
--------------------------------------------------------------------------------

Here we take a look at the raw data to get a feel for what needs cleaning. 

We first use the in-built browser with the {base} function View(). 

Then we can use the {base} function summary(), but probably the most comprehensive 
overview is with the {skimr} function. 
You can also view distinct values for variables using the {base} unique() function. 

For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#review
https://epirhandbook.com/descriptive-tables.html#browse-data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r browse_data, eval = FALSE}

# view your whole dataset interactively (in an excel style format)
View(linelist_raw)

# get summary: 
# mean, median and max values of numeric variables
# counts for categorical variables
# also gives number of NAs
summary(linelist_raw)

# get information about each variable in a dataset 
     # nb. “POSIXct” is a type of raw date class 
skim(linelist_raw)

# view unique values contained in variables 
# you can run this for any column -- just replace the column name
unique(linelist_raw$case_gender) 

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_colnames \\\
--------------------------------------------------------------------------------

Here we are going to clean the column names of our data set - and store as a new
dataset called "linelist". 

It is possible to use the {janitor} package for automated cleaning of variable 
names - but as there are only a few variables that we want to rename, 
here we will demonstrate using {dplyr} select() function for manually renaming.

Select() can be used either to retain specific columns or to rename them by using
the syntax New name = Old name. 

For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#column-names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r clean_colnames}

# create a new object called linelist and assign linelist_raw with renamed columns
linelist <- linelist_raw %>% 
  # use select() to retain columns and rename them 
     # NEW name = OLD name
     # aligned for readability
  select( 
    pid                 = PID,
    date_report         = reprt_creationdt_FALSE,      
    date_dob            = case_dob_FALSE,              
    age                 = case_age,                    
    gender              = case_gender,
    race                = case_race,
    eth                 = case_eth,
    zip                 = case_zip,
    county              = case_county,
    district            = case_district,
    state               = case_state,
    contact_id          = Contact_id, 
    date_onset          = sym_startdt_FALSE,
    sym_fever,
    sym_subjfever,
    sym_myalgia,
    sym_losstastesmell,
    sym_sorethroat,
    sym_cough,
    sym_headache,
    sym_resolved,
    date_recovery       = sym_resolveddt_FALSE, 
    contact_hh          = contact_household,
    hospitalized,  
    date_hospitalized   = hosp_admidt_FALSE,
    date_discharge      = hosp_dischdt_FALSE,
    died,  
    died_covid,  
    date_died           = died_dt_FALSE,
    confirmed_case, 
    covid_dx, 
    date_positive       = pos_sampledt_FALSE,
    lat                 = latitude_JITT,
    lon                 = longitude_JITT
    )

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_dates \\\
--------------------------------------------------------------------------------

Here we are going to clean the date variables 

It is possible to use the {janitor} package for automated cleaning of variable 
names - but as there are only a few variables that we want to rename, 
here we will demonstrate using {dplyr} select() function for manually renaming.

Select() can be used either to retain specific columns or to rename them by using
the syntax New name = Old name. 

For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#column-names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r clean_dates}

linelist <- linelist %>%
     
  # convert all date columns, ymd() from lubridate
  mutate(across(contains("date"), ymd)) %>%

  # remove onset dates prior to 2020
  mutate(
       across(
    .cols = c(date_report, date_onset, date_hospitalized, date_discharge, date_died),
    .fns  = ~replace(.x, .x < as.Date("2020-01-01"), NA)
    )) %>% 

  # remove dates after the surveillance_date (for this report) from all date columns
  mutate(across(
    .cols = contains("date"),
    .fns  =  ~replace(.x, .x > surveillance_date, NA)
    )) %>%
     
  # create an epiweek object from the report date 
  # floor_date rounds to the closest week here
  mutate(epiweek = floor_date(date_report,
                          # round by weeks
                          unit = "week", 
                          # define week to start on Wednesday
                          week_start = 3)
  )

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_numerics \\\
--------------------------------------------------------------------------------

Here we are going to clean all numeric variables, as well as create some new 
variables based on difference between dates. 

First we will ensure that age is numeric and then fix those with incorrectly 
entered dates (notice that one individual was -20 years old). 

Then we show how to create new numeric variables for the number of days between 
two dates. 


For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#num_cats
https://epirhandbook.com/cleaning-data-and-core-functions.html#clean_case_when
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r clean_numerics}

# Age 
############

linelist <- linelist %>%
  mutate(
    # ensure that age is a numeric variable
    age = as.numeric(age),
    # set those with negative ages and missing DOB to missing 
    # otherwise just leave the age value as is
          # nb. NA_real_ just ensures the variable class is not changed
    age = if_else(age < 0 & is.na(date_dob), NA_real_, age)
  )

     
# Calculating time differences 
##############################

linelist <- linelist %>%
     
  # delay from onset to hospitalization
  mutate(
    # calculate time differences
    days_onset_hosp = as.numeric(date_hospitalized - date_onset),
    # set those under 0 or over 30 to missing
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp < 0, NA),
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp > 30, NA)
  ) %>%
     
  # length of hospitalization
  mutate(
    # create outcome date based on whether died or was discharged first
    date_outcome = coalesce(date_died, date_discharge),
    # calculate time difference
    days_hosp = as.numeric(date_outcome - date_hospitalized),
    # set those under 0 or over 60 to missing
    days_hosp = replace(days_hosp, days_hosp < 0, NA),
    days_hosp = replace(days_hosp, days_hosp > 60, NA)
  )

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_categories \\\
--------------------------------------------------------------------------------

create age groups based on the age variable using 
the age_categories() function from {epikit}. It is also possible to create 
age groups using the {dplyr} case_when() function - but is more involved. 

For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#column-creation-and-transformation
https://epirhandbook.com/cleaning-data-and-core-functions.html#re-code-values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r clean_categories}

linelist <- linelist %>% 
     
     # create age group variable
     mutate(
     age_group = age_categories(age,
      # define break points
      c(0, 10, 20, 30, 40, 50, 60, 70),
      # whether last break should be highest category
      ceiling = FALSE
     )) %>% 
     
     # replace one category and leave the rest as they are 
     mutate(died_covid = if_else(died_covid == "Under Review", 
                                 "Unknown", died_covid), 
            confirmed_case = if_else(confirmed_case == "Pending", 
                                     "Unknown", confirmed_case), 
            sym_myalgia = if_else(sym_myalgia == "YES", "Yes", sym_myalgia)
            ) %>% 
     
     #replace one category and leave rest over multiple variables 
     mutate(across(c(contact_hh, contains("sym_")),
                   ~if_else(.x == "Unk", "Unknown", .x) 
                   )) %>% 

     # create a composite category from race and ethnicitiy  
          #  (nb. this sets those that are non-specified in eth to non-hispanic)
     mutate(eth_race = case_when(
          eth == "HISPANIC/LATINO"                            ~ "Hispanic, all races", 
          race == "ASIAN" & 
               eth != "HISPANIC/LATINO"                       ~ "Asian, NH", 
          race == "BLACK" & 
               eth != "HISPANIC/LATINO"                       ~ "Black, NH",
          race == "WHITE" & 
               eth != "HISPANIC/LATINO"                       ~ "White, NH",
          race == "AMERICAN INDIAN/ALASKA NATIVE" |
               race == "NATIVE HAWAIIAN/PACIFIC ISLANDER" |
               race == "OTHER" & 
               eth != "HISPANIC/LATINO"                       ~ "Other, NH", 
          TRUE                                                ~ "Unknown"
     )) %>% 
     
     # change from upper-case to lower case (with leading capital)
     mutate(across(c(county, state), str_to_title)) %>% 
     
     # remove text from a string (everything after the dash)  
     mutate(contact_id = str_remove(linelist$contact_id, "-.*")) %>% 
     
     # recode with searching for string patterns 
     mutate(sym_resolved = case_when(
          str_detect(sym_resolved, "Yes")     ~ "Yes", 
          str_detect(sym_resolved, "No")      ~ "No", 
          str_detect(sym_resolved, "Unknown") ~ "Unknown", 
          TRUE                                ~ "Unknown"
     )) %>% 
     
     
     # create a factor 
     mutate(zip = as_factor(zip)) %>% 
     
  
     # replace missing with "Unknown" where relevant 
     mutate(across(.cols = c(gender, race, eth, zip, 
                             county, contact_id, contact_hh, 
                             hospitalized, died, died_covid, confirmed_case,
                             contains("sym_"), age_group),
          ~fct_explicit_na(.x, na_level = "Unknown"))) %>% 
    
     # set levels of a factor (define order)
     mutate(gender      = fct_relevel(gender, "Female", "Male", "Unknown"), 
            eth_race    = fct_relevel(eth_race, 
                                   "Asian, NH", "Black, NH", "White, NH", 
                                   "Hispanic, all races", "Other, NH", "Unknown")
         ) %>% 
     
     # set levels of all factors that are yes/no/unknown 
     mutate(across(
          c(contact_id, contact_hh, hospitalized, died, died_covid, confirmed_case, 
            contains("sym_")), 
          ~fct_relevel(.x, "Yes", "No", "Unknown")
          ))
```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// vector_vars \\\
--------------------------------------------------------------------------------

Here we are going to store a list of variable names that we can then use for 
iterating later on rather than typing them out each time. 
In this example we are going to take all the symptom variables and store them in 
a vector. 
It is also possible to simply type these out with quotation marks within a c(...)
argument. 
For more details see: 
https://epirhandbook.com/iteration-loops-and-lists.html
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r vector_vars}

# define a list of variables for looping over later
symptom_vars <- linelist %>% 
     # choose all columns that contain "sym_" in the name but exclude "sym_resolved"
     select(c(contains("sym_"), -sym_resolved)) %>% 
     # pull the names out 
     names()

# type out the variables of interest
demographic_vars <- c("gender", "age_group", "eth_race")

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// duplicated \\\
--------------------------------------------------------------------------------

Here we remove the duplicates based on having the same pid, gender and date of 
birth. 
Note that this might exclude those which are legitimately reported twice - i.e. 
those who recovered and were reinfected. To deal with these you could create a 
composite variable of the identifiers of interest, flag the duplicates there and 
then add an additional argument for having a report date within six months. 

For more details see: 
https://epirhandbook.com/de-duplication.html 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r duplicated}

# get a list of all the duplicates 
     # this is mostly to inspect manually but can be used for analysing those dropped
duplicates <- linelist %>% 
     get_dupes(pid, gender, date_dob)

linelist <- linelist %>% 
  ## find duplicates based on unique ID, gender and date of birth and age group 
  ## only keep the first occurrence 
  distinct(pid, gender, date_dob, .keep_all = TRUE)

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// filter \\\
--------------------------------------------------------------------------------

Here we are going to filter our data set to only keep relevant cases for analysis. 
We keep those that are reported before our surveillance cut-off date and those 
that are entered as a confirmed case. 
For more details on filtering see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#filter-rows
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r filter}

# get those which do not meat our filter criteria 
dropped <- linelist %>% 
     filter(confirmed_case != "Yes" | 
                 date_report > surveillance_date & 
                 !is.na(date_report))


# drop the cases that dont meet the criteria 
linelist <- linelist %>% 
     filter(confirmed_case == "Yes" & 
              date_report <= surveillance_date & 
                 !is.na(date_report))
```

# Descriptive analysis 
This section will be analysing data by time place and person to produce descriptive
tables. 


## Time 

```{r}

## TODO: make sure this comes out in the word (error about valid_percent)
## TODO: Fix column widths 

linelist %>% 
tabyl(epiweek) %>% 
  select(-valid_percent) %>% 
  adorn_totals() %>%  
  adorn_pct_formatting(affix_sign = FALSE) %>% 
  flextable() %>% 
  autofit()

```

# Place 

```{r}

recent_period   <- c(seq(surveillance_week  - 13, surveillance_week, by = 1))
previous_period <- c(seq(surveillance_week  - 27, surveillance_week - 14, by = 1))

zip_counts <- linelist %>% 
  group_by(zip) %>% 
  summarise(
    recent   = sum(date_report %in% recent_period),
    previous = sum(date_report %in% previous_period)
  ) %>% 
  adorn_totals() %>% 
  mutate(
    perc_change = round((recent - previous) / previous * 100, digits = 1), 
    )

```



```{r}


zip_pop <- shapefile %>% 
  as_tibble() %>% 
  select(ZipCode, Population) %>% 
  adorn_totals()
  

zip_counts <- left_join(zip_counts, 
                        zip_pop, 
                        by = c("zip" = "ZipCode")
                        ) %>% 
  mutate(
    across(c(recent, previous), 
                ~round(.x / Population * 10000, digits = 1), 
                .names = "{.col}_inc"), 
    across(c(perc_change, recent_inc, previous_inc), 
           ~case_when(
             is.na(.x) ~ 0,
             .x == Inf ~ 100, 
             TRUE      ~ .x
             )
           )
    )
```


```{r}

recent_period_labels <- str_c(
  format(min(recent_period), format = "%m/%d"), 
  "-", 
  format(max(recent_period), format = "%m/%d")
)

previous_period_labels <- str_c(
  format(min(previous_period), format = "%m/%d"), 
  "-", 
  format(max(previous_period), format = "%m/%d")
)


# pick colours 
# RColorBrewer::brewer.pal(3, "RdYlGn") %>% 
#   scales::show_col()

## TODO: consider switching this to scales::col_bin
row_colour <- case_when( 
  zip_counts$perc_change < 0 ~ "#91CF60", 
  zip_counts$perc_change > 0 ~ "#FC8D59", 
  TRUE                       ~ "#FFFFBF")

## TODO: Fix column widths 

zip_counts %>% 
  select(zip, recent, recent_inc, previous, previous_inc, perc_change) %>% 
  flextable() %>% 
  bg(j = "perc_change", 
     bg = row_colour
     ) %>% 
  
  add_header_row(
    values = c("", 
               str_c("Recent 14-day reporting period\n", recent_period_labels), 
               "", 
               str_c("Previous 14-day reporting period\n", previous_period_labels), 
               "", 
               "Change between reporting periods"
               )) %>% 
  set_header_labels(
    zip          = "Zip Code", 
    recent       = "n", 
    recent_inc   = "Incidence", 
    previous     = "n", 
    previous_inc = "Incidence", 
    perc_change  = "%"
  ) %>% 
  merge_at(i = 1, j = 2:3, part = "header") %>% 
  merge_at(i = 1, j = 4:5, part = "header") %>% 
  align(align = "center", part = "header") %>% 
  bold(part = "header") %>% 
  bold(i = nrow(zip_counts), part = "body") %>% 
  footnote(j = c(3, 5), part = "header", ref_symbols = c("a"),
           value = as_paragraph("Incidence calculated as cases per 10,000 population by zip code")) %>% 
  footnote(j = 6, part = "header", ref_symbols = c("b"),
           value = as_paragraph("These reflect the percentage increase or decrease of new diagnoses between the 14 days preceding the past 7 days and the 14 days preceding that."))

```


# Person 

```{r}

total_cases <- purrr::map(
  demographic_vars,
  ~ tabyl(linelist, .x) %>%
    select("Characteristic" = .x, n, percent)
) %>% 
  bind_rows()

recent_cases <- purrr::map(
  demographic_vars, 
  ~filter(linelist, 
          date_report >= (surveillance_date - 28)) %>% 
    tabyl(.x) %>% 
    select(n, percent)
) %>% 
  bind_rows()


total_deaths <- purrr::map(
  demographic_vars, 
  ~filter(linelist, 
          died_covid == "Yes") %>% 
    tabyl(.x, show_na = TRUE) %>%
    select(n, percent)
) %>% 
  bind_rows()


recent_deaths <- purrr::map(
  demographic_vars, 
  ~filter(linelist, 
          died_covid == "Yes" & 
          date_died >= (surveillance_date - 28)) %>% 
    tabyl(.x) %>% 
    select(n, percent) %>% 
    mutate(variable = .x)
) %>% 
  bind_rows()



overall <- linelist %>% 
  summarise(
    Characteristic = "Total",
    cases = n(),
    perc  = NA, 
    cases_recent = sum(date_report >= (surveillance_date - 28)), 
    perc_recent  = NA, 
    deaths = sum(died_covid == "Yes"), 
    perc_deaths = NA, 
    deaths_recent = sum(died_covid == "Yes" & 
                          date_died >= (surveillance_date - 28)),
    perc_deaths_recent = NA, 
    variable = "Overall"
  )


demographics_counts <- bind_cols(total_cases, recent_cases, total_deaths, recent_deaths) %>% 
  mutate(across(contains("percent"), 
                ~round(.x * 100, digits = 1)
                )) 

names(overall) <- names(demographics_counts)

demographics_counts <- bind_rows(overall, demographics_counts)


percentage_cols <- names(demographics_counts) %>% 
  str_detect("percent") %>% 
  which()

gender_colours <- scales::col_bin(
  palette = c("#91CF60", "#FC8D59"), 
  domain  = c(0, 100),
  bins    = 2
)

age_colours <- scales::col_bin(
  palette = c("#91CF60","#FFFFBF", "#FC8D59"),
  domain  = c(0, 100), 
  bins    = c(0, 5, 20, 100)
)

eth_colours <- scales::col_bin(
  palette = c("#91CF60","#FFFFBF", "#FC8D59"),
  domain  = c(0, 100), 
  bins    = c(0, 10, 40, 100)
)


## TODO: Fix column widths 

demographics_counts %>% 
  flextable(
    # retain variable column for formatting but do not display it
    col_keys = names(demographics_counts)[-10]
  ) %>% 
  set_header_labels(
    "n...2"       = "Total Confirmed Cases", 
    "percent...3" = "% of Total Cases", 
    "n...4"       = "Confirmed Cases past 28 days", 
    "percent...5" = "% of Confirmed Cases past 28 days", 
    "n...6"       = "Total Confirmed Deaths", 
    "percent...7" = "% of Total Deaths", 
    "n...8"       = "Confirmed Deaths past 28 days",
    "percent...9" = "% of Confirmed Deaths past 28 days"
  ) %>% 
  align(align = "center", part = "header") %>% 
  bold(part = "header") %>% 
  bold(i = 1, part = "body") %>% 
  bg(i = ~variable == "gender",
     j = percentage_cols, bg = gender_colours) %>% 
  bg(i = ~variable == "age_group",
     j = percentage_cols, bg = age_colours) %>% 
  bg(i = ~variable == "eth_race",
     j = percentage_cols, bg = eth_colours) %>% 
  hline(i = ~Characteristic %in% c("Total", "Unknown")) %>% 
  footnote(i = ~Characteristic == "Unknown", j = 1, part = "body", ref_symbols = c("a"),
           value = as_paragraph("Unknown includes cases not yet interviewed")) %>% 
  footnote(i = 1, j = c(6, 8), part = "header", ref_symbols = c("b"),
           value = as_paragraph("Deaths refer to all persons who had a positive PCR test result for Covid-19 and there is evidence that COVID-19 was the cause of death or a significant contributor to their death."))

```





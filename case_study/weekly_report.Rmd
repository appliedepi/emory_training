---
title: "Emory Covid-19 Case Study Script"
author: "EpiRHandbook Team"
date: "13 August 2021"
output: 
     word_document: 
          keep_md: TRUE
params: 
     report_date: 2021-06-30
---


# Introduction to this case study script

This is a an example R-markdown script which demonstrates how to create an 
automated outbreak situation report for COVID-19 in Fulton county, USA.  

- We demonstrate how to import, clean and analyse your data. 
- Analysis is organised by time, place and person. 
- Text within <! > will not show in your final document. 
     - The other parts such as slashes (///), dashes (-) and tildes (~) are just aesthetic
     - These comments are used to explain the code chunks. 
     - We refer to functions in curly brackets, e.g. {dplyr} and functions end in brackets, e.g. count()
     - This comment will not show up when you knit the document. 
     - You can delete them if you want.
- Feedback & suggestions are welcome at the [GitHub issues page](https://github.com/appliedepi/emory_training/issues)
     - Alternatively email us at: [epirhandbook@gmail.com](mailto:epiRhandbook@gmail.com)


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This comment will not show up when you knit the document.
A comment with a title with slashes indicates a name of a code chunk.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// setup \\\
--------------------------------------------------------------------------------

Several packages are required for different aspects of  analysis with *R*. 
You will need to install these before starting. 

We install and load packages using the {pacman} package. 

This might prove difficult if you have limited administrative rights for your 
computer. Making sure your IT-department gives you the correct access can save a 
lot of headache. 

See this handbook pages on the basics of installing packages and running R from 
network drives (company computers) for more detail. 

https://epirhandbook.com/r-basics.html#installation
https://epirhandbook.com/r-on-network-drives.html#r-on-network-drives
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r setup, include=FALSE}

# hide all code chunks in the output, but show errors 
     # nb. warnings and messages still shown
knitr::opts_chunk$set(echo = FALSE,  # hide all code chunks in output
                      error = TRUE   # show errors if they appear, but don't stop (produce the word doc)
                     )

# Ensures the package "pacman" is installed
if (!require("pacman")) {
     install.packages("pacman") }

# install (if necessary) and load packages to be used
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways 
  skimr,      # get overview of data
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  epikit,     # age_categories() function
  tidyverse   # data management and visualization
)

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// define_current_week \\\
--------------------------------------------------------------------------------
Here we use the date you want to report on, defined in parameters above to create
a date object which we can use for filtering datasets and analysis. 

We also create a week object to make grouping data easier. In this scenario we 
have defined the week to start on Wednesdays as this is when Fulton County 
releases their reports (but you can choose any other day of the week too). 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r define_current_week}

# create a date object from the parameter
report_date <- as.Date(params$report_date)

# create an epiweek object from the date 
# floor_date rounds to the closest week here
report_week <- floor_date(report_date,
                          # round by weeks
                          unit = "week", 
                          # define week to start on Wednesday
                          week_start = 3)
```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// import \\\
--------------------------------------------------------------------------------

We use the {rio} package for importing our example data - it is very versatile 
and can read in most file types. 

We use the {here} package for defining the path to our file. This is important 
for sharing your script with others (by email or on Sharepoint) - if you used an
"absolute" path, they would need to update the script to match their computer. 

This way your whole R-project folder can be zipped up and moved somewhere else. 

For more details see: 
https://epirhandbook.com/import-and-export.html
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r import}

# import the raw data set 
# define the path using {here} then pass that to the {rio} import function 
linelist_raw <- here("case_study", "data", 
                     "covid_example_data", "covid_example_data.xlsx") %>% 
     # specify the sheet to read using which (default is to read first sheet)
     import(which = "in")

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// browse_data \\\
--------------------------------------------------------------------------------

Here we take a look at the raw data to get a feel for what needs cleaning. 

We first use the in-built browser with the {base} function View(). 

Then we can use the {base} function summary(), but probably the most comprehensive 
overview is with the {skimr} function. 
You can also view distinct values for variables using the {base} unique() function. 

For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#review
https://epirhandbook.com/descriptive-tables.html#browse-data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r browse_data, eval = FALSE}

# view your whole dataset interactively (in an excel style format)
View(linelist_raw)

# get summary: 
# mean, median and max values of numeric variables
# counts for categorical variables
# also gives number of NAs
summary(linelist_raw)

# get information about each variable in a dataset 
     # nb. “POSIXct” is a type of raw date class 
skim(linelist_raw)

# view unique values contained in variables 
# you can run this for any column -- just replace the column name
unique(linelist_raw$case_gender) 

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_colnames \\\
--------------------------------------------------------------------------------

Here we are going to clean the column names of our data set - and store as a new
dataset called "linelist". 

It is possible to use the {janitor} package for automated cleaning of variable 
names - but as there are only a few variables that we want to rename, 
here we will demonstrate using {dplyr} select() function for manually renaming.

Select() can be used either to retain specific columns or to rename them by using
the syntax New name = Old name. 

For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#column-names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r clean_colnames}

## TODO: CHECK WHICH COLUMNS WERE DROPPED AND IF USEFUL (n=10)

# create a new object called linelist and assign linelist_raw with renamed columns
linelist <- linelist_raw %>% 
  # use select() to retain columns and rename them 
     # NEW name = OLD name
     # aligned for readability
  select( 
    pid                 = PID,
    date_report         = reprt_creationdt_FALSE,      
    date_dob            = case_dob_FALSE,              
    age                 = case_age,                    
    gender              = case_gender,
    zip                 = case_zip,
    eth                 = case_eth,
    contact_id          = Contact_id, 
    date_onset          = sym_startdt_FALSE,
    sym_fever,
    sym_cough,
    sym_headache,
    sym_losstastesmell,
    sym_sorethroat,
    sym_myalgia,
    contact_hh          = contact_household,
    hospitalized,  
    date_hospitalized   = hosp_admidt_FALSE,
    date_discharge      = hosp_dischdt_FALSE,
    died,  
    died_covid,  
    date_died           = died_dt_FALSE,
    lat                 = latitude_JITT,
    lon                 = longitude_JITT
    )


```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_dates \\\
--------------------------------------------------------------------------------

Here we are going to clean the date variables 

It is possible to use the {janitor} package for automated cleaning of variable 
names - but as there are only a few variables that we want to rename, 
here we will demonstrate using {dplyr} select() function for manually renaming.

Select() can be used either to retain specific columns or to rename them by using
the syntax New name = Old name. 

For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#column-names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r clean_dates}

linelist <- linelist %>%
     
  # convert all date columns, ymd() from lubridate
  mutate(across(contains("date"), ymd)) %>%

  # remove onset dates prior to 2020
  mutate(
       across(
    .cols = c(date_report, date_onset, date_hospitalized, date_discharge, date_died),
    .fns  = ~replace(.x, .x < as.Date("2020-01-01"), NA)
    )) %>% 

  # remove dates after today from all date columns
  mutate(across(
    .cols = contains("date"),
    .fns  =  ~replace(.x, .x > Sys.Date(), NA)
    )) %>%
     
  # create an epiweek object from the report date 
  # floor_date rounds to the closest week here
  mutate(epiweek = floor_date(date_report,
                          # round by weeks
                          unit = "week", 
                          # define week to start on Wednesday
                          week_start = 3)
  )

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_numerics \\\
--------------------------------------------------------------------------------

Here we are going to clean all numeric variables, as well as create some new 
variables based on difference between dates. 

First we will ensure that age is numeric and then fix those with incorrectly 
entered dates (notice that one individual was -20 years old). 

Then we show how to create new numeric variables for the number of days between 
two dates. 


For more details see: 
https://epirhandbook.com/cleaning-data-and-core-functions.html#num_cats
https://epirhandbook.com/cleaning-data-and-core-functions.html#clean_case_when
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r clean_numerics}

# Age 
############

linelist <- linelist %>%
  mutate(
    # ensure that age is a numeric variable
    age = as.numeric(age),
    # set those with negative ages and missing DOB to missing 
    # otherwise just leave the age value as is
          # nb. NA_real_ just ensures the variable class is not changed
    age = if_else(age < 0 & is.na(date_dob), NA_real_, age)
  )

     
# Calculating time differences 
##############################

linelist <- linelist %>%
     
  # delay from onset to hospitalization
  mutate(
    # calculate time differences
    days_onset_hosp = as.numeric(date_hospitalized - date_onset),
    # set those under 0 or over 30 to missing
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp < 0, NA),
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp > 30, NA)
  ) %>%
     
  # length of hospitalization
  mutate(
    # create outcome date based on whether died or was discharged first
    date_outcome = coalesce(date_died, date_discharge),
    # calculate time difference
    days_hosp = as.numeric(date_outcome - date_hospitalized),
    # set those under 0 or over 60 to missing
    days_hosp = replace(days_hosp, days_hosp < 0, NA),
    days_hosp = replace(days_hosp, days_hosp > 60, NA)
  )

```

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// clean_categories \\\
--------------------------------------------------------------------------------

create age groups based on the age variable using 
the age_categories() function from {epikit}. It is also possible to create 
age groups using the {dplyr} case_when() function - but is more involved. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


```{r clean_categories}

## CHECK ALL THE STUFF THAT NEEDS FIXING 

for (i in names(linelist)) {
    print(i)
    print(table(linelist[[i]]))}
   
     
     
      # create age group variable
    age_group = age_categories(age,
      # define break points
      c(0, 10, 20, 30, 40, 50, 60, 70),
      # whether last break should be highest category
      ceiling = FALSE
    )
  
  # convert column classes
              # convert class
  mutate(zip = as_factor(zip)) %>% 


  # clean died column
  mutate(
    died = fct_explicit_na(died, na_level = "Unknown"),
    died = fct_relevel(died, "Yes", "No", "Unknown")
    )
  

```



```{r duplicated}

# use PID gender and dob 

```

```{r filter}

# filter(confirmed_case == "Yes")
# current week 
```






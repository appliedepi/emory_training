---
title: "Emory COVID-19 Response Collaborative"
subtitle: "Data visualization with ggplot2: an overview and demonstration"
author: '[EpiRhandbook Team](https:://epirhandbook.com) <br><br> `r icons::icon_style(icons::fontawesome("twitter"), fill = "white")` [epiRhandbook](https://twitter.com/epiRhandbook) <br> `r icons::icon_style(icons::fontawesome("paper-plane"), fill = "white")` [epirhandbook@gmail.com](mailto:epirhandbook@gmail.com)'
date: "August 2021"
output:
  xaringan::moon_reader:
    self_contained: FALSE
    seal: TRUE
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
---

```{r, echo=F}
# You need to run this line once, for the slides to render 
# remotes::install_github("mitchelloharawild/icons")
# icons::download_fontawesome()

# Use this command to run preview-mode in RStudio. Save Rmd to update slide preview
# xaringan::inf_mr()
```


```{css, echo = F}
/* THIS IS A CSS CHUNK - THIS IS A COMMENT */

/* Size of font in code echo. E.g. 10px or 50% */
.remark-code {
  font-size: 70%;
}


/* Size of font in text */

.medium-text {
  font-size: 75%;     
}

/* Size of font in tables */

.small-table table {
  font-size: 6px;     
}

.medium-table table {
  font-size: 8px;     
}

.medium-large-table table {
  font-size: 10px;     
}

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.retina = 3  ## retina more effective than w/h (according to twitter)
                      # fig.width = 16, 
                      # fig.height = 10
                      )

## I dont know why this is included in the example xaringan slide 
## but is something to do with background images
options(htmltools.dir.version = FALSE)
```


```{r}
## install and load necessary packages 
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  skimr,      # review data
  janitor,    # data cleaning and tables
  epikit,     # age categories
  lubridate,  # working with dates
  incidence2, # epidemic curves
  ggrepel,    # smart labels
  ggExtra,
  esquisse,
  apyramid,   # age pyramids
  scales,     # formatting of scales
  tidyverse,  # data management and visualization
  xaringanthemer  # for styling presentation 
)

```


```{r xaringan-themer, include = FALSE}

## define presentation colours (theme) using {xaringanthemer} package 
## https://pkg.garrickadenbuie.com/xaringanthemer/articles/xaringanthemer.html

## epirhandbook logo colours: 
  ## blue: "#00538c"
  ## green: "#007732"
  ## lighter green: "#48a878"

## see ?style_mono_accent for all the things can customise
style_mono_accent(
  base_color = "#00538c", 
  link_color = "#48a878", 
  ## add logo to the title page (bit bigger)
  title_slide_background_image = "https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/epiRhandbook_HexSticker_500x500.png", 
  title_slide_background_position = "100% 100%", 
  title_slide_background_size = "25%", 
  ## add logo to all following slides
  background_image = "https://github.com/appliedepi/emory_training/raw/master/presentation/images/AppliedEpi_Hex.png", 
  background_size = "10%",
  background_position = "100% 0%"
)

```


# We are Applied Epi  

![](https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/Epi%20R%20Handbook%20Banner%20Beige%201500x500.png)

* We are a grassroots collaborative of applied epidemiologists  
* Our (free) **Epi R Handbook** has been used by 50,000 people worldwide
* Now we offer customized training to health departments and NGOs  


.footnote[Bookmark [www.epiRhandbook.com](www.epirhandbook.com)!]  


???
- What makes us different is that we focus on the challenges of applied epi, not academic epi. We emphasize the skills used every day by ground-level epidemiologists. 


---
# Introducing ourselves  

* **Neale Batra**  
 - Founder of the Epi R Handbook.  
 - Previously @Philly, @SantaClaraCounty, and @USAID/PEPFAR. Internationally with @MSF and @WHO.  
* **Alex Spina**  
 - Alum of EPIET (European EIS). Med student and epi consultant for @MSF and @WHO.  
* **Mathilde Mousset**  
 - R programmer / Data manager at Epicentre (@MSF). PhD in evolutionary ecology.  
* **Henry Laurenson-Schafer**  
 - Epi/data scientist with WHO Geneva on COVID response. PhD in molecular biology/bioinformatics.  
* **Wen Lin** 
 - Epi @SantaClaraCounty, **Resident SAS expert**. 

???
We have Wen available for answering any questions on translating SAS to R 



---
# Today's demonstration  

Today is primarily *explanation* and *demonstration*, following from the previous [demonstration on data management and workflow](https://appliedepi.github.io/emory_training/presentation/slides_workflow.html).  

We assume you have reviewed the Handbook pages on [R Basics](https://epirhandbook.com/r-basics.html) and [ggplot basics](https://epirhandbook.com/ggplot-basics.html).  

![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/EDGE.png?raw=true)  




???
- The learning process can be summarised into this acronym "EDGE". Today's session is primarily a *demonstration* with question & answer session. We assume that you have read at least some of the relevant pages in the Epi R Handbook prior to this session. We also offer training in which we guide you through case studies with hands-on coaching. 


---
# Objectives  

Our objectives today are to:  

1) De-mystify `ggplot()` syntax so you can apply it to your own tasks  
2) Demonstrate core `geom_()` commands  
3) Introduce helpful "wrapper" packages like **incidence2** and **apyramid**  
4) Touch upon advanced tips with packages **ggExtra**, **ggrepel**, **gghighlight**, **scales**, **plotly**, and **esquisse**  


.footnote[The [Epi R Handbook](https://epirhandbook.com/index.html) contains many more examples.]  







---
# Directory structure  

Today's work is within an R project, which can be [downloaded as a zipped file](https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/appliedepi/emory_training/tree/master/case_study).  

Today's code is available to you in `ggplot_demo.Rmd` (also online [here](https://github.com/appliedepi/emory_training/blob/master/case_study/ggplot_demo.Rmd)).  

R project file (`case_study.Rproj`)  
  * `data/` folder  
    * `covid_example_data/` folder 
        * `linelist_cleaned.rds` 
        * `covid_example_data.xlsx`  
        * `covid_shapefile/` folder  
          - `FultonCountryZipCode.shp`...
    * `map_tiles/` folder 
        * base map images for Fulton County...
  * `ggplot_demo.Rmd` (R markdown script)  




---
# Load packages and import data  

Load packages, as covered in previous demonstration.  
**ggplot2** is included within [**tidyverse**](https://www.tidyverse.org/).  

```{r, eval = FALSE, echo=TRUE}
pacman::p_load(
  rio,            # import/export
  here,           # file locator
  lubridate,      # working with dates
  epikit,         # age categories, helper functions
  incidence2,     # epidemic curves
  apyramid,       # demographic pyramids
  gghighlight,    # specialized highlight plots
  ggrepel,        # smart labels
  ggExtra,        # marginal distributions and other extras
  esquisse,       # point-and-click ggplot2
* tidyverse       # mega-package for data management and visualization
  )
```

For today's purposes, we import the cleaned linelist of *fake* example data, produced from the [last demonstration](https://github.com/appliedepi/emory_training/blob/master/case_study/weekly_report.Rmd).  

```{r echo=FALSE, eval=TRUE}
# This actually runs but is not displayed
linelist <- rio::import(here::here("case_study", "data", "covid_example_data", "linelist_cleaned.rds"))
```

```{r echo=TRUE, eval=FALSE}
linelist <- import(here::here("data", "covid_example_data", "linelist_cleaned.rds"))
```


???
One tip is to load tidyverse last to avoid masking of package names  
The `import()` function can import almost any kind of file. An `.rds` file retains column classes from an R data frame.






---

class: medium-large-table

# Review data  

Below are the first 25 rows of the `linelist` data frame:  

```{r}
head(linelist, 25) %>% 
  DT::datatable(
    options = list(
      scrollY = 300,
      scrollX = 600,
      pageLength = 25,
      fontSize = '25%',
      dom = "ti",
      ordering = FALSE,
      rownames = FALSE,
      options = list(pageLength = 5, scrollX=T),
      class = 'white-space: nowrap' 
    )
  )

  #knitr::kable(format = 'html')
```

.footnote[Tip: Use `skim()` from **skimr** package to review all columns with summary statistics]  





---
# Visualization options in R  

Today we focus on **ggplot2** because it:  

* is good for fast data exploration of multi-dimensional data  
* produces very **high quality** final outputs  
* has well-structured grammar => **high consistency**  
* is accompanied by many packages that expand functionality  

See the [R graph gallery](https://www.r-graph-gallery.com/ggplot2-package.html) for inspiration.  

.footnote[Other plotting options include [**base** R](https://towardsdatascience.com/base-plotting-in-r-eb365da06b22), [**lattice**](https://www.statmethods.net/advgraphs/trellis.html), and [**plotly**](https://plotly.com/r/).]  





---
# gg-what??  

--

- The **ggplot2** *package* is the most popular data visualization tool in R  

--

- Its `ggplot()` *function* is at the core of the package  

--

- This whole approach is colloquially known as “ggploting”  

--

- Resulting figures are sometimes affectionately called “ggplots”  

--

**ggplot2** benefits from a wide variety of supplementary R packages that extends its functionalities, such as **gganimate**, **ggthemr**, **ggdendro**, **gghighlight**, **ggforce**...  

.footnote[
*Bonus question:* What does the "gg” in these names represent?
]

???
- "gg" represents the “grammar of graphics” used to construct the figures 





---
# Syntax overview  

Build a plot object by “adding” commands on top of one another that specify plot layers and design elements  


--

The order of layers will usually look like this:

1) **"Open" the plot** with the `ggplot()` command and specify the dataset  

--

2) **"Map" data columns** to "aesthetic" features of the plot such as axes, color, size, shape, fill, transparency  

--

3) **Add (`+`) “geom” layers** that visualize data geometrically as shapes  

--

4) **Modify "scales"**, such as a color scale or y-axis breaks  

--

5) **Add design elements** such as axis labels, title, caption, fonts, text sizes, background themes, or axes rotation  

--

These layers are "added" sequentially with `+` symbols.  
**ggplot2** commands can be quite long!  


???
Remember that although the commands may be long, it is infinitely easier to edit and recycle than in Excel  







---
# Open the plot  

.pull-left[

`ggplot()` creates an empty canvas. Assign the data frame to use.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)                   
```

Alternatively, use the `%>%` pipe operator to "pipe" a data frame *into* `ggplot()`  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
linelist %>%
  ggplot()
```

]

.pull-right[

```{r , echo = FALSE, eval = TRUE}
ggplot(data = linelist)
```
] 

???
This is only a blank canvas, we have not defined what should be in the x and y axes. 
If several data frames are needed, they can be added in their own geoms.
Piping is useful to make one-time changes to a dataset prior to plotting.  



---
# Mappings with `aes()`  

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
* mapping = aes(
*  x = age,
*  y = days_hosp))
```

"Aesthetics" are features *whose display could vary for each data point* (position, color, shape...)  

`mapping = aes()` assigns plot "aesthetics" to columns in the data. Inputs must be placed within `aes()`.  

Two basic aesthetic mappings are axes, via `x=` and `y=`.  


]

.pull-right[

```{r , echo = FALSE, eval = TRUE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp))+
theme_grey(base_size = 16)
```
] 



---
# Add geometry  

.pull-left[

```{r eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) +
*geom_point()
```

Data are visualized using "geom" commands, such as `geom_point()`.  

These commands are "added" with a `+` to the `ggplot()` command.  

]


.pull-right[

```{r eval=T, echo=F, message=F, warning=F}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) +
geom_point() +
  theme_grey(base_size = 16)
```

]




---
# Geometries  

.pull-left[

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`
Points          |`geom_point()`  


.footnote[Full list [here](https://ggplot2.tidyverse.org/reference/)]  

]


.pull-right[

```{r, message=F, warning=F}

# Histogram
histogram <- ggplot(
    data = linelist,
    mapping = aes(
      x = date_onset))+
  geom_histogram(fill = "darkorange")+
  labs(title = "geom_histogram()")+
  theme_minimal(base_size = 16)
  

points <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_hosp)
    )+
  geom_point()+
  labs(title = "geom_point()")+
  theme_minimal(base_size = 16)


cowplot::plot_grid(histogram, points,
                          nrow = 2, rel_widths = c(2,2))

#cowplot::plot_grid(top, lines, ncol = 1)

```

]






---
# Geometries  

.pull-left[

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`  
Points          |`geom_point()`  
Lines           |`geom_line()`  
Bar plots       |`geom_bar()` or `geom_col()`  


.footnote[Full list [here](https://ggplot2.tidyverse.org/reference/)]

]


.pull-right[

```{r, message=F, warning=F}

lines <- linelist %>% 
  group_by(eth_race,
           week_report = lubridate::floor_date(date_report, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_report) %>% 
  ggplot(
    mapping = aes(
      x = week_report,       
      y = n_cases,
      color = eth_race),
    size = 4
    )+
  geom_line()+
  labs(title = "geom_line()")+
  theme_minimal(base_size = 16)

bars <- linelist %>% 
  ggplot(mapping = aes(
      y = died,
      fill = died))+
  geom_bar()+
  labs(title = "geom_bar()")+
  theme_minimal(base_size = 16)+
  theme(legend.position = "none")

cowplot::plot_grid(lines, bars,
                   nrow = 2, rel_widths = c(2,2))


```

]





---
# Geometries  

.pull-left[

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`
Points          |`geom_point()`  
Lines           |`geom_line()`  
Bar plots       |`geom_bar()` or `geom_col()`  
Boxplots        |`geom_boxplot()`  
Violin plots    |`geom_violin()`  


.footnote[Full list [here](https://ggplot2.tidyverse.org/reference/)]

]


.pull-right[

```{r, message=F, warning=F}

boxplots <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = age)
    )+
  geom_boxplot()+
  labs(title = "geom_boxplot()")+
  theme_minimal(base_size = 16)



violins <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = days_hosp,
      fill = died)
    )+
  geom_violin()+
  labs(title = "geom_violin()")+
  theme_minimal(base_size = 16)


cowplot::plot_grid(boxplots, violins,
                          #smooth, density,
                          
                          nrow = 2, rel_widths = c(2,2))


```

]








---
# Adding geoms  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp)) +
*geom_point()
```

With axes now mapped, `geom_point()` displays the data as points.  

]

.pull-right[


```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp)) +
geom_point() +
theme_grey(base_size = 16)
```

] 











---
# Adding geoms  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp)) +
geom_point() +
*geom_smooth()
```

We can add additional geoms to the current plot with `+`.  

*Geoms appear in the order they are written*: the smoothed line appears over the points.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) +
geom_point() +
geom_smooth() +
theme_grey(base_size = 16)
```
] 

.footnote[geom_smooth() gives smoothed conditional means, helping to show trends in presence of "over-plotting" (see [documentation](https://ggplot2.tidyverse.org/reference/geom_smooth.html))]


???
- Explain why you might use one or the other





---
# A quick note on indentations  

Indentations, spaces, and newlines do not impact code execution, and can be varied to improve readability.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist, mapping = aes(x = age, y = days_hosp))+geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(x = age, y = days_hosp)) +
geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,        # use case linelist
  mapping = aes(          # make aesthetic mappings for all geoms
    x = age,              # assign x-axis to age column
    y = days_hosp)) +     # assign y-axis to duration of hospitalization
geom_point()              # display data as points
```



???
- Explain why you might use one or the other 
long style can enable informative comments/annotations
- short style very dense (harder to read for some). Shorter scripts, but so what? The number of lines of your code is not an informative metric.
- very long lines => needs to scroll horizontally for people with smaller monitors (not nice)
- long-ish style makes it easier to see which argument belongs to each function
- spaces around "=" or "+" => make it easier to parse to many people
- other?













---

class: large-table

# Other aesthetics  

Aside from axes, other common "aesthetics" include: 

Argument        |Controls                
----------------|-----------------------
`shape`      |Display of point as dot, star, triangle, square...
`fill`       |The *interior* color (e.g of bar or boxplot)  
`color`      |The *exterior* or bar, boxplot - OR point color  
`size`       |Line thickness, point size...
`alpha`      |Transparency (1 = opaque, 0 = invisible)
`width`      |Width of "bar plot" bars
`linetype`   |Either solid, dashed, dotted, etc.  
`binwidth`   |Width of histogram bins  
  


???

Note that “aesthetic” in ggplot has a specific meaning that you might associate with the word “aesthetics” in common English. In ggplot those details are called “themes” and are adjusted within a theme() command

Each geom accepts certain aesthetics, like `binwidth=` for `geom_histogram()`






---

class: medium-text

# Aesthetics assignments  


.pull-left[

Aesthetics can be assigned to either:  

* **Static values**: `color = "purple"`  
  - Assigned *outside* `aes()`  
  - Same display for all data  

* **A data column**: `aes(color = died)`  
  - Assigned *inside* `aes()`
  - Displays data as "groups"  
  

]


.pull-right[

Some examples:  

```{r, message=F, warning=F}

color_purple <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(color = "purple")+
  theme_minimal(base_size = 16)+
  labs(title = "Using color = 'purple'")

color_died <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(aes(color = died))+
  theme_minimal(base_size = 16)+
  labs(title = "Using aes(color = died)")

cowplot::plot_grid(color_purple, color_died,
                  nrow = 2, rel_widths = c(2,2))


```

]




---

class: medium-text

# Aesthetics assignments  


.pull-left[

Aesthetics can be assigned to either:  

* **Static values**: `fill = "purple"`  
  - Assigned *outside* `aes()`  
  - Same display for all data  
  
* **A data column**: `aes(fill = died)`  
  - Assigned *inside* `aes()`
  - Displays data as "groups"  
  

]


.pull-right[

More examples:  

```{r, message=F, warning=F}

fill_purple <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(fill = "purple")+
  theme_minimal(base_size = 16)+
  labs(title = "Using fill = 'purple'")


fill_died <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(aes(fill = died))+
    theme_minimal(base_size = 16)+
  labs(title = "Using aes(fill = died)")

cowplot::plot_grid(
                  fill_purple, fill_died,
                   
                   nrow = 2, rel_widths = c(2,2))


```

]





```{r, message=F, warning=F, eval=F}

shape_3 <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(shape = 3)+
  theme_minimal()+
  labs(title = "shape = 3")

shape_died <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(aes(shape = died))+
  theme_minimal()+
  labs(title = "aes(shape = died)")

###

fill_purple <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(fill = "purple")+
  theme_minimal()+
  labs(title = "fill = 'purple'")


fill_died <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(aes(fill = died))+
    theme_minimal()+
  labs(title = "aes(fill = died)")

###

col <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(fill = "lightgreen", color = "purple")+
  theme_minimal()+
  labs(title = "fill = 'lightgreen', color = 'purple'")


col_died <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(aes(fill = died), color = "black")+
  theme_minimal()+
  labs(title = "aes(fill = died), color = 'black'")


cowplot::plot_grid(shape_3, shape_died,
                  fill_purple, fill_died,
                   col, col_died,
                   ncol = 2, rel_widths = c(2,2))


```









---
# Static aesthetics  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) + 
*geom_point(color = "seagreen")
```


An aesthetic is *static* if it applies the same display to all data points in the geom or plot. Static aesthetics are defined *outside* `aes()` to a *number or character value*.  

Other examples:  
`size = 3`  
`alpha = 0.5`  
`width = 1.2`  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
     x = age,
     y = days_hosp)) +
geom_point(color = "seagreen") +
theme_grey(base_size = 16)
```
] 






---
# Dynamic aesthetics   

.pull-left[

```{r, echo = TRUE, eval = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
*   color = died)) +
geom_point()
```


*Dynamic* aesthetics are mapped to a column name, and defined *inside* `aes()`. This creates "groups" in the plot and generates a legend. The display varies for each data point.  

Above, `color=` is mapped to column `died`, and is inherited by `geom_point()`.   

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died)) +   
geom_point()+
theme_grey(base_size = 16)
```
]

???




---
# Multiple aesthetics - example  

.pull-left[


```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
*   color = died)) +  
geom_point(
* size = 7, 
* alpha = 0.7) 
```

Above, `size = 7` and `alpha = 0.7` are static aesthetics defined outside any `aes()` and apply to `geom_point()`.  

`color =` is within an `aes()`, and maps to values in column `died`.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died))+      # color varies by outcome
geom_point(size = 7,     # all points 7x size
           alpha = 0.7)+ # transparency 
theme_grey(base_size = 16)     
```
]

.footnote[Read more about ggplot aesthetics [here](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html)]  


???
As there is only one geom, all aesthetics can be written in `ggplot()`, or in `geom_point()`




---
# Aesthetic mapping placement  

* Dynamic mappings in the initial `ggplot()` call will apply to subsequent geoms, *unless otherwise indicated*  
* Static aesthetics (e.g. `color = "blue"`) are not inherited by subsequent geoms  
* Mappings written within one geom apply only to that geom  

.pull-left[
```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(                
  data = linelist,      
  mapping = aes(        
    x = age,
    y = days_hosp)) +
# points colored by outcome
  geom_point(
  mapping = aes(color = died),
  size = 1) +
# smoothed means by outcome
geom_smooth(
  mapping = aes(color = died),
  size = 3) +
# smoothed mean of entire dataset
geom_smooth(color = "black")
```
]

.pull-right[
```{r, echo = F, eval = T, tidy = FALSE}
ggplot(                
  data = linelist,      
  mapping = aes(        
    x = age,
    y = days_hosp)) +
# points colored by outcome
  geom_point(
  mapping = aes(color = died),
  size = 1) +
# smoothed means by outcome
geom_smooth(
  mapping = aes(color = died),
  size = 3) +
# smoothed mean of entire dataset
geom_smooth(color = "black") +
theme_minimal(base_size = 16)
```
]


???
- Which is cleaner and easier to read?
- When would you want to assign different dynamic aesthetics for different layers? E.g. Points colored by outcome, but geom_text in black only. 
- Explain why you might use one or the other  
- Note that aesthetics written outside will not automatically be inherited. 



---
# A common error  

.pull-left[

If your data are "grouped", yet you plot indiscriminately without the grouping assigned to a dynamic aesthetic, you get multiple y values per x value.  

Below, `linelist` is aggregated into counts per unique week-outcome.  

```{r, eval=F, echo = T, warning=F, message=F}
outcome_week_data <- linelist %>% 
* count(died,
*       week_onset = floor_date(
*        x = date_onset,
*        unit = "week")) %>% 
  select(week_onset, everything()) %>% 
  arrange(week_onset) %>% 
  drop_na(week_onset)
```
]


.pull-right[
First few rows:  

```{r, eval=T, echo = F, warning=F, message=F}
outcome_week_data <- linelist %>% 
  count(
    died,
    week_onset = lubridate::floor_date(
      x = date_onset,
      unit = "week")) %>% 

  select(week_onset, everything()) %>% 
  arrange(week_onset) %>% 
  drop_na(week_onset)

outcome_week_data %>%
  head(8) %>% 
  knitr::kable()
```

]



---
# A common error  

.pull-left[

```{r, echo=T, eval=F}
ggplot(
* data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n)) +
geom_line()
```

Above, the column `died` is not provided to any grouping aesthetic.  

`ggplot()` does not know how to display the multiple values for each week.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n)) +
geom_line()+
theme_grey(base_size = 16)

```

]



---

# A common error - resolved  

.pull-left[

```{r, echo=T, eval=F}
ggplot(
  data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n,
*   color = died))+
geom_line()
```

Use aesthetic mappings like `fill=` or `color=` to correctly visualize the "groups".  

Above, `color=` is mapped to the `died` column.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n,
    color = died)) +
geom_line()


```
]



---
# Facets  



.pull-left[

```{r , echo = TRUE, eval = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(~eth_race)
```

Another way of *displaying groups* is via faceting. 

Place a "~" before the column name.  

`facet_wrap()` produces one facet per unique value.  

] 



.pull-right[

```{r }
ggplot(data = linelist,
       mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_wrap(~ eth_race)+
  theme_grey(base_size = 16)
```

]

???
Also called "small multiples"  


---

# Facets  

.pull-left[

```{r , echo = TRUE, eval = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(~eth_race,
            scales = "free_y")
```

"Free" auto-scaled axes with `scales=`. Options:  
- "free_y"  
- "free_x"   
- "free" (both x and y)  

] 

.footnote[
Alert your audience if you use free axes! 
Also, try `ncol=` and `nrow=`  

]


.pull-right[
```{r }
ggplot(data = linelist,
       mapping = aes(x = date_onset)) +
geom_histogram() +
facet_wrap(~eth_race,
           scales = "free_y") +
labs(caption = "Note the free y-axis")+
theme_grey(base_size = 16)
```

]




---
# Facets - by two variables


.pull-left[

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(eth_race ~ gender) 
```


The "~" signifies "by". You can place columns on either side.  
  
With `facet_wrap()`, levels are combined into facet titles, appearing alphabetically/by factor level.  

] 


.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
facet_wrap(eth_race ~ gender) + 
theme_grey(base_size = 16)
```

]




---
# Facets - grid layout


.pull-left[

Use `facet_grid()`. Labels appear on top and side.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_grid(eth_race ~ gender) 
```

] 


.pull-right[

```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
facet_grid(eth_race ~ gender) + 
theme_grey(base_size = 16)
```

]


---
# Facets - drop levels


.pull-left[

Use `filter()` or `drop_na()` in advance, to remove undesired levels.  

```{r , echo = TRUE, eval = FALSE}
linelist %>% 
*  drop_na(gender, eth_race) %>% 
*  filter(gender != "Unknown") %>% 
  
  # begin plot
  ggplot(
    mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_grid(eth_race ~ gender) 
```

] 


.pull-right[

```{r }
linelist %>% 
  drop_na(gender, eth_race) %>% 
  filter(gender != "Unknown") %>% 
  
  ggplot(
    mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_grid(eth_race ~ gender) +
  theme_grey(base_size = 16)
```

]

.footnote[Above, we pipe the adjusted data frame into `ggplot()`, for ease]  



---
# Facets + `gghighlight()`

.pull-left[

Add `gghighlight()` from **gghighlight** to show a full "shadow" behind each facet. For color add the `aes(fill=)`.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = date_onset,
*   fill = eth_race)) +
geom_histogram() +
facet_wrap(~ eth_race) +
*gghighlight::gghighlight()
```

] 


.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(
    x = date_onset,
    fill = eth_race)) +
geom_histogram() +
facet_wrap(~ eth_race) +
gghighlight::gghighlight() +
theme_minimal(base_size = 14)
```

]





---
# gghighlight

.pull-left[

Add `gghighlight()` to other plots, and specify specific values (or criteria) to highlight 

```{r, echo=T, eval=F}
linelist %>% 
  # get daily counts by zip code
  group_by(age_group, date_report) %>%
  count() %>% 
  
  # plot
  ggplot(
    mapping = aes(
      x = date_report,
      y = n,
      color = age_group)) +
  geom_line() +
* gghighlight::gghighlight(
    age_group %in% c("40-49", "60-69)"))+
  theme(legend.position = "none")
  
```




] 


.pull-right[
```{r echo=F, eval=T}
linelist %>% 
  # get daily counts by zip code
  group_by(age_group, date_report) %>%
  count() %>% 
  
  # plot
  ggplot(
    mapping = aes(
      x = date_report,
      y = n,
      color = age_group)) +
  geom_line()+
  gghighlight::gghighlight(age_group %in% c("40-49", "60-69")) +
  theme(legend.position = "none")
```

]




---
# Scales - overview  

Scale commands replace defaults of *how* the aesthetic mappings manifest, such as:  
* *Which* colors or shapes to display  
* The min/max of point sizes  
* The min/max and frequency of axes breaks  

As a generic formula, these commands are written as: **`scale_AESTHETIC_METHOD()`**.  

1) `scale_` : this prefix never changes  
2) AESTHETIC: `_fill_` , `_color_` , `_x_` , `_y_` , etc.  
3) METHOD: `_continuous()`, `_discrete()`, `_manual()`, `_date()` etc.





---
# Scales examples  

Some examples of scale commands:  

You want to adjust  |Scale command
--------------------|-------------------
continuous y-axis   |`scale_y_continuous()`
date x-axis         |`scale_x_date()`  
categorical x-axis  |`scale_x_discrete()`  
fill, continuous    |`scale_fill_continuous()`
fill, continuous    |`scale_fill_gradient()`  
color, manual assign|`scale_color_manual()`  




---
# Scales - default 

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar()
```


Above, the fill of a bar plot uses the **default colors and axis breaks**:  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar() +
  theme_gray(base_size = 18)
```

]



---
# Scales - adjusted fill 

.pull-left[


```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar() +
*scale_fill_manual(        
*  values = c(
*   "Yes"     = "violetred", 
*   "No"      = "aquamarine",
*   "Unknown" = "grey"))


```

Within `scale_fill_manual()` we provide assignments within a vector `c()`.  


.footnote[Use *na.value = "grey"* for missing values]  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar() +
scale_fill_manual(        
  values = c(
    "Yes" = "violetred", 
    "No" = "aquamarine",
    "Unknown" = "grey")) +
theme_gray(base_size = 16)
```
]

???
Discuss the na.value= arguments in most scale commands, and the difference between having NA values in the data and having an explicit missing value such as "Unknown".


---
# Scales - adjusted y-axis 

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar() +
scale_fill_manual(        
  values = c(
    "Yes"     = "violetred", 
    "No"      = "aquamarine",
    "Unknown" = "grey")) +
*scale_y_continuous(
*  breaks = seq(from = 0,
*               to = 35000,
*               by = 5000))
```

In `scale_y_continuous()` we adjust the y-axis breaks using `seq()` to define a numeric sequence.   

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar() +
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey")) +
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000)) +
theme_gray(base_size = 18)
```

]





---
# Scales - "Floating plots" 

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar() +
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey")) +
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
* expand = c(0, 0)) +
*scale_x_discrete(
*  expand = c(0, 0))
```

In any `scale_x_` or `scale_y_` command, use `expand = c(0,0)` to remove excess space around the plot features.  

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
  geom_bar() +
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey")) +
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
  expand = c(0,0)) +
scale_x_discrete(
  expand = c(0,0)) +
theme_grey(base_size = 18)
```

]




---
# Scales - date axis labels

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram()
```

The default scale for date axes will vary by the range of your data.  

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram()+
theme_grey(base_size = 18)

```

]







---
# Scales - date label breaks

.pull-left[


```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*scale_x_date(
*  date_breaks = "3 months")

```

Adjust axis labels with `scale_x_date()`.  

Use `date_breaks=` values like "1 week", "2 weeks", or "3 months". 


Note: these are the *axis* label breaks, not histogram bin breaks!  

.footnote[
Note: Default "weeks" start on Mondays. See [epiRhandbook epicurves](https://epirhandbook.com/epidemic-curves.html) page for alternatives.
]

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months") +
theme_grey(base_size = 18)

```

]

???
For tips on geom_histogram() bins, see Epi R Handbook epicurves page








---
# Scales - date axis labels

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
* date_labels = "%d %b\n%Y")

```

Specify date label format to `date_labels=` using ["strptime" syntax](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/strptime)  

`"%d %b %Y"` for DD MMM YYYY.  


See Epi R Handbook [Epicurves](https://epirhandbook.com/epidemic-curves.html) and [Strings](https://epirhandbook.com/characters-and-strings.html) pages for more tips

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
  date_labels = "%d %b\n%Y"
) +
theme_grey(base_size = 18)

```

]


???
/n is a newline






---
# Scales - date axis labels

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
* labels = scales::label_date_short() )

```

Alternatively, simplify by assigning `labels=` to `label_date_short()` from [**the scales package**](https://scales.r-lib.org/)  

The year is not repeated on each label anymore.  

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
  labels = scales::label_date_short())+
theme_grey(base_size = 18)

```

]

.footnote[Note the use above of `labels=`, not `date_labels=`.]







---

class: medium-large-table  

# Scales - display percents  

.pull-left[

Easily display proportions as percents with `percent()` from **scales** within `scale_y_continuous()`.  

```{r, echo=F, eval=T}
# no lag accounted for, for simplicity
CFR_data <- linelist %>% 
  group_by(month = floor_date(date_report, "month")) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes", na.rm=T),
    CFR = deaths / cases)

```


First few rows of a CFR dataset:  

```{r, echo=F, eval=T}
CFR_data %>% 
  head(4) %>%
  knitr::kable()
```

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
*   y = CFR) +
geom_line(size = 2, color = "brown") +
*scale_y_continuous(labels = percent)
```

] 

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
    y = CFR)) +
geom_line(size = 2, color = "brown")+
scale_y_continuous(labels = percent) +
theme_grey(base_size = 18)

```
]


???
Remember to load the scales package




---
# Labels  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist) +
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3) +
*labs(
*  title = "Duration of admission",
*  x = "Age (years)",
*  y = "Duration (days)",
*  caption = "Fictional COVID-19 data",
*  color = "Deceased"
)
```

Use `lab()` to edit title, subtitle, caption, axes labels, and legend title  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist)+
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3) +
labs(
  title = "Duration of admission",
  x = "Age (years)",
  y = "Duration (days)",
  caption = "Fictional COVID-19 data",
  color = "Deceased"
) +
theme_grey(base_size = 18)
```
]



---
# Label tips  

See the [Epi R Handbook page](https://epirhandbook.com/characters-and-strings.html#dynamic-strings) on adjusting characters with the **stringr** package

**New lines**  

```{r, eval=F, echo=T}
"Top line\nNextline"                        # \n creates new line
str_wrap("This is a really long title", 30) # wrap at 30 characters
```


--


**Dynamic labels** - Imbed code in `str_glue()` that updates with the data  

```{r, eval=T, echo=T}
str_glue("Data as of {Sys.Date()}")
```

```{r, eval=T, echo=T}
str_glue("{fmt_count(linelist, is.na(date_onset))} cases missing onset and not shown")
```


--


**Legend title**  
In `labs()`, write the aesthetic (e.g. `fill=`, `color=`) and provide a title.  



???
Explain that in str_glue, anything within curly brackets it will run as R code.  







---
# Themes  

.pull-left[

Themes are non-data design features (background, text size/color, etc).  

[These "complete themes"](https://ggplot2.tidyverse.org/reference/ggtheme.html) are easy to add.  

```{r, eval=F, echo=T}
# Try one of these...
theme_bw()+
theme_classic()+
theme_dark()+
theme_gray()+
theme_minimal()+
theme_light()+
theme_void()+
```

Try the argument `base_size = 16` to quickly increase text size.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}

minimal <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_minimal()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_minimal(base_size = 18)



bw <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_bw()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_bw(base_size = 18)



grey <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_grey()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_grey(base_size = 18)


dark <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_dark()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_dark(base_size = 18)



void <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_void()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_void(base_size = 18)



light <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_light()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_light(base_size = 18)


themes_plots <- cowplot::plot_grid(
  minimal, light,
  bw, grey,
  dark, void,
  nrow = 3, rel_widths = c(2,2))

themes_plots

```



]






---
# Themes  

.pull-left[

Use `theme()` to make micro-adjustments.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
    alpha = 0.3) +
geom_point() +
labs(
  title = "Duration of admission",
  x = "Age (years)",
  y = "Duration (days)",
  color = "Deceased")+
theme_minimal(base_size = 16) +
*theme(
* legend.position = "bottom",
* plot.title = element_text(
*   color = "red",
*   face = "bold"),
* axis.title.y = element_text(angle = 90))
```

]

.pull-right[

Syntax takes practice - see [this list](https://ggplot2.tidyverse.org/reference/theme.html) of feature-specific arguments.

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "Duration of admission",
    x = "Age (years)",
    y = "Duration (days)",
    color = "Deceased")+
  theme_minimal(base_size = 16)+
  theme(
    legend.position = "bottom",
    plot.title = element_text(color = "red",
                              size = 20,
                              face = "bold"),
    axis.title.y = element_text(angle = 0))
```
]

???
Talk about these theme() arguments and how they consist of two parts, just like `mapping = aes()`. 
Explain that nobody has these all memorized, but the common ones are easy to remember once you use them enough.  
Remember to add them AFTER any complete themes.





---
# Bar plots  

`geom_col()` and `geom_bar()` are used to make general bar plots (non-epicurves).

--

Use `geom_bar()` if bar height should reflect the **number of rows** in the data
(e.g. a case linelist).  

```{r, echo=T, eval=F}
ggplot(
  data = linelist,                  # begin with linelist
  mapping = aes(x = eth_race)) +    # No y= argument
*geom_bar()                           
```

--

Use `geom_col()` there is a numeric column containing the desired **bar height**
(e.g. aggregated count data).  

```{r, eval=F, echo=T}
ggplot(
  data = linelist_agg,                  # begin with aggregated count data   
  mapping = aes(x = eth_race, y = n)) + # bar height is value in column "n"                                     
*geom_col()   
```







---

class: medium-table

# Bar plot - count rows  

.pull-left[

With `geom_bar()`, the height reflects the number of rows per x-axis group. This works well for linelist data.  

```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(
  data = linelist,
  mapping = aes(x = eth_race)) +             
geom_bar() +
theme(axis.text.x= element_text(angle=30))  
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(x = eth_race)) +             
geom_bar()+                  
theme_grey(base_size = 16) +
theme(axis.text.x= element_text(angle = 30))
```
]

---

class: medium-table

# Bar plot - count grouped rows  

.pull-left[

To achieve "stacked" bars with `geom_bar()`, assign the grouping column to `fill=`, within `aes()`.  

```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(
  data = linelist,
  mapping = aes(
      x = eth_race,   
*     fill = died)) +             
geom_bar() + 
theme(axis.text.x= element_text(angle=30))
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(
      x = eth_race,   
      fill = died)) +             
geom_bar()+   # stack bars by column "died"  
theme_grey(base_size = 16)+
theme(axis.text.x= element_text(angle = 30))
```
]



---

class: medium-table

# Bar plot - counts  

.pull-left[

In contrast, `geom_col()` uses a column of counts, such as column `n` in this `linelist_eth` dataset:

```{r, eval=T, echo=F}
linelist_eth <- linelist %>% 
  count(eth_race)

linelist_eth %>% 
  head(6) %>% 
  knitr::kable()
```

Column `n` provides the bar height.    

```{r, echo=T, eval=F}
ggplot(linelist_eth) +             
*  geom_col(           
    mapping = aes(   
      x = eth_race,    
*     y = n))+
theme(axis.text.x= element_text(angle = 30))         
```


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist) +             
  geom_bar(              
    mapping = aes(
      x = eth_race))+
theme_grey(base_size = 16)+
theme(axis.text.x= element_text(angle = 30))
  
```


]


---

# Bar plot - a common error 

.pull-left[

If your data look like this (counts) and your plot looks like that (bars of same height), ensure you are using `geom_col()` and not `geom_bar()`!  

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  knitr::kable()
```

]

.pull-right[

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  ggplot()+
  geom_bar(
    mapping = aes(x = eth_race))+
  theme_grey(base_size = 16)
```

This plot shows that there is one row per ethnicity/race!  

]

---

class: medium-table

# Bar plot - stacked counts  

.pull-left[

To have "stacked" bars using `geom_col()`, each plotting group must have its own rows in the data. Use "long"-style data like below:  

```{r, echo = F, eval=T}
linelist_eth_died <- linelist %>% 
  count(eth_race, died)

linelist_eth_died %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist_eth_died) +               
geom_col(                 
  mapping = aes(
    x = eth_race,          
*   y = n,                
*   fill = died)) +
theme(axis.text.x= element_text(angle=30))
```

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died) + # begin with data aggregated by day/ethnicity              
  geom_col(                # column height by aggregated counts
    mapping = aes(
      x = eth_race,            # one bar per ethnicity. 
      y = n,               # bar height from column "n"
      fill = died)) +        # stacked bars by outcome
theme_grey(base_size = 16)+
theme(axis.text.x= element_text(angle = 30))
```

]



---
# Bar plot - flip axes  

.pull-left[

It is simple to flip the axes on any ggplot by adding `coord_flip()`  


```{r, echo=T, eval=F}
ggplot(linelist) +        
geom_bar(              
  mapping = aes(
    x = eth_race,            
    fill = died)) +
theme(legend.position = "top") +  
* coord_flip()           
```


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist) +             
  geom_bar(              
    mapping = aes(
      x = eth_race,          
      fill = died)) + 
coord_flip() + 
theme_grey(base_size = 16)+
theme(legend.position = "top")  

```
]





---
# Bar plot - adjust order    

.pull-left[



```{r, echo=T, eval=F}
ggplot(linelist) +        
geom_bar(                
  mapping = aes(
*   x = fct_infreq(eth_race),   
*   fill = fct_infreq(died))) + 
theme(legend.position = "top") +  
coord_flip()
```

Use the **forcats** package to convert to class *factor* and adjust "level" order.  

Above, `fct_infreq()` orders x-axis position and stacks (fill) by frequency.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist) +             
geom_bar(              
  mapping = aes(
    x = fct_infreq(eth_race),   
    fill = fct_infreq(died))) +  
coord_flip() + 
theme_grey(base_size = 16)+
theme(legend.position = "top") 
```
]



.footnote[See the Epi R Handbook page on [factors](https://epirhandbook.com/factors.html#within-a-plot).]  



???
You will need to clean up the axes and legend titles now.  


---
# Bar plot - reverse order  

.pull-left[


```{r, echo=T, eval=F}
ggplot(linelist)  +              
geom_bar(                
  mapping = aes(
*   x = fct_rev(fct_infreq(eth_race)),   
*   fill = fct_rev(fct_infreq(died)))) +      
theme(legend.position = "top") + 
coord_flip()              
```


To *reverse* order, use `fct_rev()`, which can be wrapped around other functions. 

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist) +             
geom_bar(              # column height by number of rows
  mapping = aes(
    x = fct_rev(fct_infreq(eth_race)),            
    fill = fct_rev(fct_infreq(died)))) +     
coord_flip() + 
theme_grey(base_size = 16) +
theme(legend.position = "top") 
```

]






---


# Bar plot - adjust width  

.pull-left[

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died)) +             
*geom_col(width = 0.5) +
theme(axis.text.x = element_text(angle = 30))

```

Adjust bar width with `width=`.  

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died,
       aes(x = eth_race, y = n, fill = died)) +             
  geom_col(width = 0.5) + 
  theme_grey(base_size = 16)+
theme(axis.text.x = element_text(angle = 30))
```

]

???
Be wary of adjusting width for date bars (e.g. month) - use `geom_histogram()` instead with bin breaks.  




---


# Bar plot - adjacent  

.pull-left[


```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = fct_infreq(died),
    label = n)) +             
*geom_col(position = "dodge")+
theme(axis.text.x = element_text(angle = 30))
```

To make the bars adjacent, specify `position = "dodge"` in `geom_col()`.  

.footnote[Adjust the order with via a **forcats** function.]

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = fct_infreq(died),
    label = n)) +             
  geom_col(position = "dodge") + 
  theme_grey(base_size = 16)+
theme(axis.text.x = element_text(angle = 30))
```

]



---


# Bar plot - display counts  

.pull-left[

To display text, add `geom_text()` with `aes(label=)` assigned to the height column.  

The `position=` arg in `geom_text()` can specify display at mid-bar.  

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died,
*   label = n)) +             
geom_col() +
*geom_text(
* size = 3,
* position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle=30))
```

.footnote[
It is best to use `geom_col()` if displaying text.
Also, try `geom_label()` for boxes around the text.  
]

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died,
       aes(x = eth_race, y = n, fill = died, label = n)) +             
geom_col() +
geom_text(size = 3, position = position_stack(vjust = 0.5)) + 
theme_grey(base_size = 16) +
theme(axis.text.x = element_text(angle=30))
```

]










---

# Point-and-click ggplot2  

Now that you've learned the basic syntax... the [**esquisse**](https://cran.r-project.org/web/packages/esquisse/vignettes/get-started.html]) package allows point-and-click creation of (simple) ggplots! (esquisse means "sketch" in French)  

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/esquisse1.gif?raw=true")
```






---
# Make an epidemic curve  

Two approaches that we suggest:  

1) Use the **incidence2** package  
  * Fast, simple, and modifiable with ggplot additions  
  
2) Use ggplot's `geom_histogram()`  
  * Most customizeability  
  * Most complex code  

--

Today's demonstration will focus on **incidence2**.  

.footnote[See the Epi R handbook's [Epicurves page](https://epirhandbook.com/epidemic-curves.html) for detailed examples of both methods]  








---
# Epicurve - make incidence object 

.pull-left[

**Create** an incidence object  

```{r, echo=T, eval=F}
weekly <- incidence(
  x = linelist,            
  date_index = date_onset, 
  interval = "week")          
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly)
```
]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
weekly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "week")       # bin interval   

plot(weekly)
```

]




---
# Epicurve - incidence object 

.pull-left[

Adjust the interval

```{r, echo=T, eval=F}
bimonthly <- incidence(
  x = linelist,            
  date_index = date_onset, 
* interval = "2 months")      
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(bimonthly)
```

Try "Sunday weeks" or "MMWR week" for Sunday weeks.  

]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
bimonthly <- incidence(
  x = linelist,            
  date_index = date_onset, 
  interval = "2 months")    

plot(bimonthly)
```

]




---
# Epicurve - groups 

.pull-left[

To show groups, specify them to `groups=` in the `incidence()` command:  

```{r, echo=T, eval=F}
weekly <- incidence(
  x = linelist,              
  date_index = date_onset,  
  interval = "weeks",       
* groups = eth_race)      
```

AND to `fill=` in the `plot()` command:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly,
* fill = eth_race)
```

If grouping by multiple columns, nest them in both places within `c()`:  

```{r, eval=F, echo=T}
groups = c(eth_race, gender)
```

]

.pull-right[



```{r, echo=F, eval=T}
weekly <- incidence(
  x = linelist,              
  date_index = date_onset,  
  interval = "weeks", 
  groups = eth_race) 

plot(weekly,
  fill = eth_race)+
  theme_minimal(base_size = 16)
```

]









---
# Epicurve - groups 


.pull-left[

Add other **ggplot2** commands with `+`.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly, fill = eth_race) +
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
*scale_y_continuous(
* expand = c(0,0),
* breaks = seq(0,2000,250)) + 
*theme_minimal(base_size = 16) + 
*theme(legend.position = "top") +
*labs(fill = "Race and\nEthnicity")
```

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly, fill = eth_race) +
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
scale_y_continuous(
 expand = c(0,0),
 breaks = seq(0,2000,250)) + 
theme_minimal(base_size = 16) + 
theme(legend.position = "top") +
labs(fill = "Race and\nEthnicity")
```

]




---
# Epicurve - date axis 

.pull-left[

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly,
  fill = eth_race,
*  date_format = "%a %d %b %Y\n (Week %W)", 
*  angle = 30)+                           
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
theme_minimal(base_size = 16) + 
theme(legend.position = "top") +
labs(fill = "Race and\nEthnicity")
```


Do not adjust **incidence2** epicurves with `scale_x_date()`.  

Instead, use custom **incidence2** arguments in `plot()`.  

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly,
  fill = eth_race,
  date_format = "%a %d %b %Y\n (Week %W)", 
  angle = 30)+                          
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
theme_minimal(base_size = 16) + 
theme(legend.position = "top") +
labs(fill = "Race and\nEthnicity")
```

]








---
# Epicurve - show cases 

.pull-left[

For small outbreaks, the style `show_cases = TRUE` may be helpful:  

```{r, eval=F, echo=T, warning=F, message=F}
small_outbreak <- linelist %>% 
  filter(
    zip == 30024,
    date_report >= as.Date("2020-12-01")) %>% 
  incidence(
    date_index = date_onset,               
    interval = "Sunday weeks",             
    groups = eth_race)
```

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(small_outbreak,
  fill = eth_race,
* show_cases = TRUE)+
theme(legend.position = "bottom")+
labs(
  title = "ZIP 30024 from Dec 2020 by race")
```

]

.pull-right[

```{r, echo=F, eval=T}
small_outbreak <- linelist %>% 
  filter(zip == 30024,
         date_report >= as.Date("2020-12-01")) %>% 
  incidence(
    # dataset is piped in from above
    date_index = date_onset,               
    interval = "Sunday weeks",             
    groups = eth_race)
```

```{r, echo=F, eval=T}
plot(small_outbreak,
  fill = eth_race,
 show_cases = TRUE)+
theme(legend.position = "bottom")+
labs(
  title = "ZIP 30024 from Dec 2020 by race") +
theme_minimal(base_size = 16)
```

]

???
Dataset is piped in from above






---
# Epicurve - color palettes  

.pull-left[

Use `scale_fill_viridis_d()` for palettes that are color-blind friendly:  

```{r, echo=T, eval=F}
plot(weekly, fill = eth_race)+
*scale_fill_viridis_d(
    option = "inferno",           
    name = "Race and\nEthnicity",  
    na.value = "grey")          
```

[Viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) (try with `option = "plasma"` or "inferno"), and [colorbrewer](https://www.r-graph-gallery.com/38-rcolorbrewers-palettes.html) palette functions can be added to any ggplot as well.  

.footnote[The `_d()` indicates a scale for discrete values]  

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly, fill = eth_race)+
   scale_fill_viridis_d(
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values
```


]



---

# Epicurve - aggregated counts  



.pull-left[

You can also use **incidence2** on data that are aggregated counts...  

```{r, eval=F, echo=T}
# For demo: aggregate linelist
linelist_day_counts <-linelist %>% 
*  count(
*    day = floor_date(date_report, "day"),
*    died) %>% 
  drop_na(day)
```

```{r, eval=T, echo=F}
# For demo: aggregate linelist
linelist_day_counts <-linelist %>% 
  count(
    day = floor_date(date_report, "day"),
    died) %>% 
  drop_na(day)
```

]

.pull-right[
A few rows of daily counts:  

```{r, eval=T, echo=F}
linelist_day_counts %>% 
  tail(10) %>% 
  knitr::kable(row.names = F)
```

]



---

# Epicurve - aggregated counts  

.pull-left[

```{r, eval=F, echo=T}
died_curve <- incidence(  
  linelist_day_counts,  
  date_index = day,   
* count = n,            
  interval = "week",    
  groups = died        
  )
```

```{r, eval=F, echo = T}
# plot stacked by outcome
plot(died_curve,    
     fill = died)   
```

]

.pull-right[

```{r, eval=T, echo=F}
died_curve <- incidence(   
  linelist_day_counts,   # dataset with counts aggregated by day
  date_index = day,      # column with dates
  count = n,             # column with counts
  interval = "week",     # aggregate daily counts up to weeks
  groups = died          # group by outcome
  )
```

```{r, eval=T, echo=F}
# plot the weekly incidence epi curve, with stacked bars by hospital
plot(died_curve,         # incidence object
     fill = died)        # color the bars by outcome
```

]


---
# Demographic pyramids  

We suggest two ways to make age pyramids:  

1) Use the **apyramid** package - simple, easy  

2) Use **ggplot2** - more customizeable, but opportunity for error  


Today we will demonstrate **apyramid**.  

.footnote[See the Epi R Handbook [page on demographic pyramids](https://epirhandbook.com/demographic-pyramids-and-likert-scales.html) and the [package vignette](https://cran.r-project.org/web/packages/apyramid/vignettes/intro.html) for more information.]  



---
# Demographic pyramids

The function `age_pyramid()` from **apyramid** offers an easy interface:  

.pull-left[

```{r, echo=F, eval=T}
linelist <- linelist %>% 
  mutate(
    gender = na_if(gender, "Unknown"), # convert to NA 
    gender = fct_drop(gender))         # drop unused factor levels
```

```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender")
```

.footnote[We have cleaned `gender` to only two values]  


]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender")
```

]



---
# Demographic pyramids

.pull-left[

Further modifications:  

* Percents instead of raw counts on the x-axis  
* No mid-point designation  
* Specified colors  

```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
* proportional = TRUE,
* show_midpoint = FALSE,
* pal = c("darkgreen", "brown"))
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE,
  pal = c("darkgreen", "brown"))+
theme_minimal(base_size = 10)

```

]


---
# Demographic pyramids

.pull-left[

You can stack the bars by another variable with `stack_by=`  

```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
* stack_by = "hospitalized"
 proportional = TRUE,
 show_midpoint = FALSE,
 pal = c("darkgreen", "brown", "yellow", "orange"))
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  stack_by = "hospitalized",
  proportional = TRUE,
  show_midpoint = FALSE,
  pal = c("darkgreen", "brown", "yellow", "orange"))+
theme_minimal(base_size = 10)

```

]


---
# Demographic pyramids

You can add further ggplot commands 

.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE) +
*theme_minimal(base_size = 10) +
*labs(
*  title = "Age and Gender",
*  subtitle = "Fulton County, GA",
*  x = "Percent of total",
*  y = "Age group",
*  fill = "Gender",
*  caption = "Caption here")
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE) +
theme_minimal(base_size = 10) +
labs(
  title = "Age and Gender",
  subtitle = "Fulton County, GA",
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
  caption = "Caption here")
```

]


---
# Dynamic labels example

Let's use dynamic labels that will update with the data.  


```{r, eval=T, echo=F}
library(epikit)
```

**Simple caption**
```{r, eval=T, echo=T}
str_glue("n = {nrow(linelist)}")
```


--

**Complex caption**  


For complicated `str_glue()` scenarios, define the dynamic components outside the quotation marks.  

`fmt_count()` from **epikit** is useful to count and display rows.  

```{r, eval=T, echo=T}
str_glue("{missing} missing age or gender not shown.",
        missing = fmt_count(linelist, is.na(gender) | is.na(age_group))
        )
```



---
# Dynamic labels example


**Subtitle**  

Max/Min dates can be wrapped in `format()` from **base** to adjust the display. See the epiRhandbook section on [strptime syntax](https://epirhandbook.com/working-with-dates.html?q=strptime#format).  

```{r, eval=T, echo=T}
str_glue("Fulton County, reported {min_date} - {max_date}",
    min_date = format(min(linelist$date_report, na.rm=T), "%B %d %Y"),
    max_date = format(max(linelist$date_report, na.rm=T), "%B %d %Y")
    )
```







---
class: remark-code

# Dynamic captions

Now applying those dynamic captions:  

.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE) +
theme_minimal(base_size = 16) +
labs(
  title = "Age and Gender",
* subtitle = str_glue(
    "Fulton County, reported {min_date} - {max_date}",
  
    min_date = format(
      min(linelist$date_report, na.rm=T),
      "%B %d %Y"),
  
    max_date = format(
      max(linelist$date_report, na.rm=T),
      "%B %d %Y")
  ),
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
* caption = str_glue(
    "{missing} missing age or gender not shown.",
    missing = fmt_count(
      linelist,
      is.na(gender) | is.na(age_group))
    )
  )
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE)+
theme_minimal(base_size = 16)+
labs(
  title = "Age and Gender",
  subtitle = str_glue(
  "Fulton County, reported {min_date} - {max_date}",
  
  min_date = format(
    min(linelist$date_report, na.rm=T),
    "%b %d %Y"),
  
  max_date = format(
    max(linelist$date_report, na.rm=T),
    "%b %d %Y")
  ),
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
  caption = str_glue(
    "{missing} missing age or gender not shown.",
    missing = fmt_count(
      linelist,
      is.na(gender) | is.na(age_group))
    )
  )
```

]







---

class: medium-table

# Labeling  


.pull-left[
 
To demonstrate labeling points, we create a new dataset that summarizes CFR and median age by race/ethnicity

```{r, echo=T, eval=T}
race_CFR_age <- linelist %>% 
  group_by(eth_race) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes", na.rm=T),
    CFR = deaths/cases,
    med_age = median(age, na.rm=T),
    med_dur = median(days_hosp, na.rm=T)
  )
```

]

.pull-right[

```{r, echo=F, eval=T}
head(race_CFR_age, 5) %>% 
  knitr::kable()
```
]








---

# Labeling  

.pull-left[
 
We can plot these data as points, and label them with `geom_text()`... but it does not look very good.  

```{r, echo=T, eval=F}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = eth_race)) +
geom_point() +
*geom_text()
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = eth_race)) +
  geom_point() +
  geom_text()
```

]









---

# Labeling  

.pull-left[
 
Labels look much improved by using `geom_label_repel()` from the **ggrepel** package:  

```{r, echo=T, eval=F}
library(ggrepel)

ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = eth_race)) +     # text to display
geom_point() +
*geom_label_repel(         # add labels
*   size = 5,               # text size
*   min.segment.length = 0) # show connector lines
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = eth_race)) +
  geom_point() +
 geom_label_repel(
    size = 5,
    min.segment.length = 0)
```

]








---

# Labeling  

.pull-left[
 
`labels=` can be assigned complex values with `str_glue()`:  

```{r, echo=T, eval=F}
library(ggrepel)

ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = str_glue("{eth_race}\n{cases} cases"))) +
geom_point() +
geom_label_repel(
    size = 5,
    min.segment.length = 0)
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = str_glue("{eth_race}\n{cases} cases"))) +
  geom_point() +
 geom_label_repel(
   size = 5,
   min.segment.length = 0)
```

]






---

# Labeling  

.pull-left[
 
Use `comma()` from the **scales** package to make numbers display with comma separators every three digits.  

```{r, echo=T, eval=F}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = str_glue("{eth_race}\n{scales::comma(cases)} cases"))) +
geom_point() +
geom_label_repel(
    size = 4,
    min.segment.length = 0)
```

See the many other useful functions in [**scales**](https://scales.r-lib.org/).  

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = str_glue("{eth_race}\n{scales::comma(cases)} cases"))) +
geom_point() +
geom_label_repel(
   size = 4,
   min.segment.length = 0)
```

]



---

# Marginal distributions  

.pull-left[

Add "marginal" histograms to scatterplots with `ggMarginal()` from the **ggExtra** package.  

```{r, eval=F, echo=T}
scatterplot <- ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) + 
geom_point()
```

```{r, eval=F, echo=T}
ggExtra::ggMarginal(
  scatterplot,                   
  type = "histogram",            
  fill = "lightblue",            
  xparams = list(binwidth = 10), 
  yparams = list(binwidth = 5))  
```
]

.pull-right[
```{r}
scatterplot <- ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) + 
geom_point()

ggExtra::ggMarginal(
  scatterplot,                   # add marginal histograms
  type = "histogram",            # specify histograms
  fill = "lightblue",            # bar fill
  xparams = list(binwidth = 10), # other parameters for x-axis marginal
  yparams = list(binwidth = 5))  # other parameters for y-axis marginal
```

]









---
# Combining plots - plot 1

The **cowplot** package facilitates combining multiple plots, while aligning elements such as axes.  

```{r, echo=F, message=F, warning=F}
library(cowplot)
```

.pull-left[

```{r, echo=T, eval=F, warning=F, message=F}
plot1 <- plot2 <- linelist %>% 
  ggplot(
    mapping = aes(
      x = date_report),
    binwidth = 7)+
  geom_histogram()+
  theme_minimal()+
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),
*   limits = c(
*     as.Date("2020-03-01"),
*     max(linelist$date_report, na.rm=T)),
    date_breaks = "months",
    labels = scales::label_date_short())
```
]

.pull-right[

```{r, echo=F, eval=T, warning=F, message=F}
plot1 <- plot2 <- linelist %>% 
  ggplot(
    mapping = aes(
      x = date_report),
    binwidth = 7)+
  geom_histogram()+
  theme_minimal()+
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),
    limits = c(as.Date("2020-03-01"), max(linelist$date_report, na.rm=T)),
    date_breaks = "months",
    labels = scales::label_date_short())

plot1
```

]

---

# Combining plots - plot 2 

.pull-left[

```{r, echo = T, eval=F}
plot2 <- linelist %>% 
  group_by(week = floor_date(date_report, "week")) %>% 
  summarise(ci = list(mean_cl_normal(age) %>% rename(mean=y, lwr=ymin, upr=ymax))) %>% 
  unnest() %>%  
  
  ggplot(
    mapping = aes(
      x = week,
      y = mean,
      ymin = lwr,
      ymax = upr))+
  geom_ribbon(alpha = 0.5, fill = "green", color = "green")+
  geom_line(size = 2, color = "darkgreen")+
  scale_x_date(
*   limits = c(
*     as.Date("2020-03-01"),
*     max(linelist$date_report, na.rm=T)),
    expand = c(0,0),
    date_breaks = "months",
    labels = scales::label_date_short()
  )+
  coord_cartesian(ylim = c(30, 60))+
  theme_minimal()+
  labs(
    y = "Weekly mean age (95%CI)",
    x = "Month")
```

]

.pull-right[


```{r, echo = F, eval=T, warning=F, message=F}
plot2 <- linelist %>% 
  # filter(date_report >= as.Date("2020-03-01"),
  #        date_report < as.Date("2021-04-01")) %>% 
  group_by(week = floor_date(date_report, "week")) %>% 
  summarise(ci = list(mean_cl_normal(age) %>% rename(mean=y, lwr=ymin, upr=ymax))) %>% 
  unnest() %>%  
  ggplot(
    mapping = aes(
      x = week,
      y = mean,
      ymin = lwr,
      ymax = upr))+
  geom_ribbon(alpha = 0.5, fill = "green", color = "green")+
  geom_line(size = 2, color = "darkgreen")+
  scale_x_date(
    limits = c(as.Date("2020-03-01"), max(linelist$date_report, na.rm=T)),
    expand = c(0,0),
    date_breaks = "months",
    labels = scales::label_date_short()
  )+
  coord_cartesian(ylim = c(30, 60))+
  theme_minimal()+
  labs(
    y = "Weekly mean age (95%CI)",
    x = "Month")

plot2

```

]




---

# Combining plots - result  

```{r, echo = TRUE}
plot_grid(plot1, 
          plot2, 
          rel_heights = c(1, 1), 
          ncol = 1, 
          align = "hv")
```



---
# Dual-axis - plot 1  

.pull-left[
You can also use **cowplot** to overlap two plots and create a "dual-axis" plot.  

Define the first plot:  

```{r, eval=F, echo=T}
plot1 <- ggplot(
  data = linelist,
  mapping = aes(
    x = date_report)) + 
geom_histogram(color = "grey",
               alpha = 0.5) +
*theme_cowplot() +
scale_x_date(
* limits = c(
*   as.Date("2020-03-01"),
*   max(linelist$date_report, na.rm = TRUE)),  
  date_breaks = "months",
  labels = scales::label_date_short(),
  expand = c(0, 0),
  name = "") +
scale_y_continuous(
  expand = c(0,0),
  name   = "Weekly reported case incidence")
```
]


.pull-right[

```{r, eval=T, echo=F}
plot1 <- ggplot(
  data = linelist,
  mapping = aes(
    x = date_report)) + 
geom_histogram(color = "grey", alpha = 0.5)+
theme_cowplot()+
scale_x_date(
 limits = c(
   as.Date("2020-03-01"),
   max(linelist$date_report, na.rm=T)),  
  date_breaks = "months",
  labels = scales::label_date_short(),
  expand = c(0,0),
  name = "")+
scale_y_continuous(
  expand = c(0,0),
  name = "Weekly reported case incidence")
plot1
```

]


---

# Dual-axis - plot 2

.pull-left[

```{r, eval=F, echo=T}
plot2 <- linelist %>% 
  group_by(epiweek) %>% 
  summarise(
    CFR = sum(died == "Yes", na.rm=T) / n() 
    ) %>% 
ggplot(
  mapping = aes(
    x = epiweek,
    y = CFR))+
    geom_line(size = 2, color = "orange")+
* theme_cowplot()+
  scale_y_continuous(
*   position = "right",
    limits = c(0, 0.2),
    expand = c(0,0),
    name = "Weekly CFR")+
  scale_x_date(
*   limits = c(
*     as.Date("2020-03-01"),
*     max(linelist$date_report, na.rm=T)),  
    date_breaks = "months",
    labels = scales::label_date_short(),
    expand = c(0,0),
    name = "Epiweek")+
  theme(
    axis.text.y = element_text(color = "orange", face = "bold"),
    axis.title.y = element_text(color = "orange", face = "bold")
  )
```

]

.pull-right[

```{r, eval=T, echo=F}
plot2 <- linelist %>% 
  group_by(epiweek) %>% 
  summarise(
    CFR = sum(died == "Yes", na.rm=T) / n() 
    ) %>% 
ggplot(
  mapping = aes(
    x = epiweek,
    y = CFR))+
    geom_line(size = 2, color = "orange")+
  theme_cowplot()+
  scale_y_continuous(
    position = "right",
    limits = c(0, 0.2),
    expand = c(0,0),
    name = "Weekly CFR")+
  scale_x_date(
    limits = c(as.Date("2020-03-01"), max(linelist$date_report, na.rm=T)),  
    date_breaks = "months",
    labels = scales::label_date_short(),
    expand = c(0,0),
    name = "Epiweek")+
  theme(
    axis.text.y = element_text(color = "orange", face = "bold"),
    axis.title.y = element_text(color = "orange", face = "bold")
  )
plot2
```

]


---

# Dual-axis - combined

```{r echo = TRUE}
aligned  <- align_plots(plot1, plot2, align = "hv")
combined <- ggdraw(aligned[[1]]) + draw_plot(aligned[[2]])
combined
```



---

# Interactive plots  

Use the **ggplotly** package to convert most ggplots to interactive plots.  

```{r echo = TRUE}
age_plot <- linelist %>% 
  group_by(week = floor_date(date_report, "week")) %>% 
  summarise(ci = list(mean_cl_normal(age) %>% rename(mean=y, lwr=ymin, upr=ymax))) %>% 
  unnest() %>%  
  ggplot(
    mapping = aes(
      x = week,
      y = mean,
      ymin = lwr,
      ymax = upr))+
  geom_ribbon(alpha = 0.5, fill = "green", color = "green")+
  geom_line(size = 2, color = "darkgreen")+
  scale_x_date(
    limits = c(as.Date("2020-03-01"), max(linelist$date_report, na.rm=T)),
    expand = c(0,0),
    date_breaks = "months",
    labels = scales::label_date_short()
  )+
  coord_cartesian(ylim = c(30, 60))+
  theme_minimal()+
  labs(
    y = "Weekly mean age (95%CI)",
    x = "Month")
```

```{r, eval=F}
plotly::ggplotly(age_plot)
```



---

# Data structure  

**ggplot2** works best when the dataset is in "long" format, where each variable has its own column. We recommend that you become familiar with `pivot_longer()` from **dplyr** (see the [Epi R Handbook pivoting page](https://epirhandbook.com/pivoting-data.html)).  
   

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/pivoting.png?raw=true")
```






---

# Helpful charts  

.pull-left[

For color & fill use names or hex code  

```{r, eval = TRUE, echo = FALSE, fig.height=4}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/ggplot_colors.png?raw=true")
```
]

.pull-right[

For shapes, try these numeric codes:  

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/ggplot_shapes.png?raw=true")
```
]



---
# Thank you  




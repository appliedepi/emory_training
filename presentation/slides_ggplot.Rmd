---
title: "Emory COVID-19 Response Collaborative"
subtitle: "Data visualization with ggplot2: an overview and demonstration"
author: '[EpiRhandbook Team](https:://epirhandbook.com) <br><br> `r icons::icon_style(icons::fontawesome("twitter"), fill = "white")` [epiRhandbook](https://twitter.com/epiRhandbook) <br> `r icons::icon_style(icons::fontawesome("paper-plane"), fill = "white")` [epirhandbook@gmail.com](mailto:epirhandbook@gmail.com)'
date: "August 2021"
output:
  xaringan::moon_reader:
    self_contained: FALSE
    seal: TRUE
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
---

```{r, echo=F}
# You need to run this line once, for the slides to render 
# icons::download_fontawesome()

# Use this command to run preview-mode in RStudio. Save Rmd to update slide preview
# xaringan::inf_mr()
```


```{css, echo = F}
/* THIS IS A CSS CHUNK - THIS IS A COMMENT */

/* Size of font in code echo. E.g. 10px or 50% */
.remark-code {
  font-size: 70%;
}


/* Size of font in text */

.medium-text {
  font-size: 75%;     
}

/* Size of font in tables */

.small-table table {
  font-size: 6px;     
}

.medium-table table {
  font-size: 8px;     
}

.medium-large-table table {
  font-size: 10px;     
}

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.retina = 3  ## retina more effective than w/h (according to twitter)
                      # fig.width = 16, 
                      # fig.height = 10
                      )

## I dont know why this is included in the example xaringan slide 
## but is something to do with background images
options(htmltools.dir.version = FALSE)
```


```{r}
## install and load necessary packages 
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  skimr,      # review data
  janitor,    # data cleaning and tables
  epikit,     # age categories
  lubridate,  # working with dates
  incidence2, # epidemic curves
  ggrepel,    # smart labels
  apyramid,   # age pyramids
  tidyverse,  # data management and visualization
  xaringanthemer  # for styling presentation 
)

```


```{r xaringan-themer, include = FALSE}

## define presentation colours (theme) using {xaringanthemer} package 
## https://pkg.garrickadenbuie.com/xaringanthemer/articles/xaringanthemer.html

## epirhandbook logo colours: 
  ## blue: "#00538c"
  ## green: "#007732"
  ## lighter green: "#48a878"

## see ?style_mono_accent for all the things can customise
style_mono_accent(
  base_color = "#00538c", 
  link_color = "#48a878", 
  ## add logo to the title page (bit bigger)
  title_slide_background_image = "https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/epiRhandbook_HexSticker_500x500.png", 
  title_slide_background_position = "100% 100%", 
  title_slide_background_size = "25%", 
  ## add logo to all following slides
  background_image = "https://github.com/appliedepi/emory_training/raw/master/presentation/images/AppliedEpi_Hex.png", 
  background_size = "10%",
  background_position = "100% 0%"
)

```


# We are Applied Epi  

![](https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/Epi%20R%20Handbook%20Banner%20Beige%201500x500.png)

* We are a grassroots collaborative of applied epidemiologists  
* Our (free) **Epi R Handbook** has been used by 50,000 people worldwide
* Now we offer customized training to health departments and NGOs  


.footnote[Bookmark [www.epiRhandbook.com](www.epirhandbook.com)!]  


???
- What makes us different is that we focus on the challenges of applied epi, not academic epi. We emphasize the skills used every day by ground-level epidemiologists. 


---
# Introducing ourselves  

* **Neale Batra**  
 - Founder of the Epi R Handbook.  
 - Previously @Philly, @SantaClaraCounty, and @USAID/PEPFAR. Internationally with @MSF and @WHO.  
* **Alex Spina**  
 - Alum of EPIET (European EIS). Med student and epi consultant for @MSF and @WHO.  
* **Mathilde Mousset**  
 - R programmer / Data manager at Epicentre (@MSF). PhD in evolutionary ecology.  
* **Henry Laurenson-Schafer**  
 - Epi/data scientist with WHO Geneva on COVID response. PhD in molecular biology/bioinformatics.  
* **Wen Lin** 
 - Epi @SantaClaraCounty, **Resident SAS expert**. 

???
We have Wen available for answering any questions on translating SAS to R 



---
# Today's session   

Today is primarily *explanation* and *demonstration*, following from the previous [demonstration on data management and workflow](https://appliedepi.github.io/emory_training/presentation/slides_workflow.html).  

We assume you have reviewed the Handbook pages on [R Basics](https://epirhandbook.com/r-basics.html) and [ggplot basics](https://epirhandbook.com/ggplot-basics.html).  

![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/EDGE.png?raw=true)  




???
- The learning process can be summarised into this acronym "EDGE". Today's session is primarily a *demonstration* with question & answer session. We assume that you have read at least some of the relevant pages in the Epi R Handbook prior to this session. We also offer training in which we guide you through case studies with hands-on coaching. 


---
# Outline

Today's demonstration will include:  

* Setting the scene (directory, packages, data import)  
* Fundamentals of ggplot  
* Data structure for **ggplot2**  
* Scatter plots  
* Bar plots  
* Dynamic labels and captions  
* Smart text labels for data  
* Epidemic curves with **incidence2**    
* Demographic pyramids with **apyramid**  
* Highlighting with **gghighlight**  
* Advanced tips such as **scales** and **gganimate**  


The Epi R Handbook contains more examples and more complex plots, for your personal reading  







---
# Visualization options in R  

Today we focus on **ggplot2** because:  

* It is good for fast data exploration of multi-dimensional data  
* It produces very high quality final outputs  
* Is accompanied by many packages that expand functionality  
* Has well-structured grammar = consistency  

Other plotting options include [**base** R](https://towardsdatascience.com/base-plotting-in-r-eb365da06b22), [**lattice**](https://www.statmethods.net/advgraphs/trellis.html), and [**plotly**](https://plotly.com/r/).  












---
# Directory structure  

Today's R work is conducted within a dedicated R project, which is a directory that contains:  

R project file (`case_study.Rproj`)  
  * `data/` folder  
    * `covid_example_data.xlsx`  
    * `covid_shapefile/` folder  
      - `FultonCountryZipCode.shp`...
  * `ggplot_demo.Rmd` (R markdown script)  
  
Read more in [this Epi R Handbook page](https://epirhandbook.com/r-projects.html) about best-practices using R projects and the **here** package.  

```{r, echo = F, eval=F}
fs::dir_tree(path = here::here("case_study", "data", "covid_example_data"), recurse = TRUE)
```








---
# Load packages  

**ggplot2** is included within the **tidyverse** mega-package (read more [here](https://www.tidyverse.org/)).  

```{r, eval = FALSE, echo=TRUE}
pacman::p_load(
  rio,            # import/export
  here,           # file locator
  lubridate,      # working with dates
  incidence2,     # epidemic curves
  apyramid,       # demographic pyramids
  gghighlight,    # specialized highlight plots
  ggrepel,        # smart labels
* tidyverse       # mega-package for data management and visualization
  )
```

The **tidyverse** also includes these packages useful for plots:  
* **dplyr** (data management)  
* **stringr** (characters and text)  
* **forcats** (factors / ordered categories)  
* and many others...  


???
One tip is to load tidyverse last to avoid masking of package names  





---

# Import data

Today we begin with a clean dataset in order to focus on visualization techniques. See the R markdown script from the previous session for all the cleaning code.  

* Use `import()` from **rio** to import a file  
* Use `here()` from **here** to locate the file relative to the R project root

```{r echo=FALSE, eval=TRUE}
# This actually runs but is not displayed
linelist_raw <- rio::import(here::here("case_study", "data", "covid_example_data", "covid_example_data.xlsx"))
```

```{r echo=TRUE, eval=FALSE}
linelist_raw <- import(here::here("data", "covid_example_data.xlsx"))
```


.footnote[The `import()` function can import almost any kind of file. If using the example data, adjust this file path according to your directory structure
]





```{r, echo=F}
linelist <- linelist_raw %>% 
  filter(confirmed_case == "Yes") %>% 
  
  select(                                       # use select() to retain columns
    date_report  = reprt_creationdt_FALSE,      # (it can also be used to re-name)
    date_dob     = case_dob_FALSE,              # NEW name = OLD name
    age          = case_age,                    # aligned for readability
    gender       = case_gender,
    zip          = case_zip,
    eth          = case_eth,
    race         = case_race,
    Contact_id, 
    date_onset   = sym_startdt_FALSE,
    sym_fever,
    sym_cough,
    sym_headache,
    sym_losstastesmell,
    sym_sorethroat,
    sym_myalgia,
    contact_hh        = contact_household,
    hospitalized,
    date_hospitalized = hosp_admidt_FALSE,
    date_discharge    = hosp_dischdt_FALSE,
    died,
    died_covid,
    date_died         = died_dt_FALSE,
    lat               = latitude_JITT,
    lon               = longitude_JITT) %>% 
  
  # convert column classes
  mutate(age = as.numeric(age)) %>%             # convert class
  mutate(zip = as_factor(zip)) %>% 
  mutate(across(contains("date"), ymd)) %>%     # convert all date columns, ymd() from lubridate

  # clean died column
  mutate(
    died = fct_explicit_na(died, na_level = "Unknown"),
    died = fct_relevel(died, "Yes", "No", "Unknown")
    ) %>% 
  
  # remove onset dates prior to 2020
  mutate(across(
    .cols = c(date_report, date_onset, date_hospitalized, date_discharge, date_died),
    .fns  = ~ replace(.x, .x < as.Date("2020-01-01"), NA)
    ))%>% 
  
  # Remove dates after today from all date columns
  mutate(across(
    .cols = contains("date"),
    .fns  =  ~ replace(.x, .x > Sys.Date(), NA)
    )) %>% 
  
  # delay onset to hospitalization
  mutate(
    days_onset_hosp = as.numeric(date_hospitalized - date_onset),
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp < 0, NA),
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp > 30, NA)
    ) %>% 

  # length hospitalization
  mutate(
    date_outcome = coalesce(date_died, date_discharge),
    days_hosp = as.numeric(date_outcome - date_hospitalized),
    days_hosp = replace(days_hosp, days_hosp < 0, NA),
    days_hosp = replace(days_hosp, days_hosp > 60, NA)
    ) %>% 
  
  mutate(eth_race = case_when(
          eth == "HISPANIC/LATINO"                            ~ "Hispanic, all races", 
          race == "ASIAN" & 
               eth != "HISPANIC/LATINO"                       ~ "Asian, NH", 
          race == "BLACK" & 
               eth != "HISPANIC/LATINO"                       ~ "Black, NH",
          race == "WHITE" & 
               eth != "HISPANIC/LATINO"                       ~ "White, NH",
          race == "AMERICAN INDIAN/ALASKA NATIVE" |
               race == "NATIVE HAWAIIAN/PACIFIC ISLANDER" |
               race == "OTHER" & 
               eth != "HISPANIC/LATINO"                       ~ "Other, NH", 
          TRUE                                                ~ "Unknown"
     )) %>% 
  # set levels of a factor (define order)
     mutate(gender      = fct_relevel(gender, "Female", "Male", "Unknown"), 
            eth_race    = fct_relevel(eth_race, 
                                   "Asian, NH", "Black, NH", "White, NH", 
                                   "Hispanic, all races", "Other, NH", "Unknown")
         ) %>% 
  
       # create age group variable
     mutate(
     age_group = age_categories(age,
      # define break points
      c(0, 10, 20, 30, 40, 50, 60, 70),
      # whether last break should be highest category
      ceiling = FALSE
     ))

```







---

class: medium-large-table

# Review data  

Below are the first 25 rows of the `linelist` data frame:  

```{r}
head(linelist, 25) %>% 
  DT::datatable(
    options = list(
      scrollY = 300,
      scrollX = 600,
      pageLength = 25,
      fontSize = '25%',
      dom = "ti",
      ordering = FALSE,
      rownames = FALSE,
      options = list(pageLength = 5, scrollX=T),
      class = 'white-space: nowrap' 
    )
  )

  #knitr::kable(format = 'html')
```

.footnote[Tip: Use `skim()` from **skimr** package to review all columns with summary statistics]  





---

# Data structure  

**ggplot2** works best when the dataset is in "long" format, where each variable has its own column. We recommend that you become familiar with `pivot_longer()` from **dplyr** (see the [Epi R Handbook pivoting page](https://epirhandbook.com/pivoting-data.html)).  
   

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/pivoting.png?raw=true")
```







---
# gg-what??  

--

- The **ggplot2** *package* is the most popular data visualization tool in R  

--

- Its `ggplot()` *function* is at the core of the package  

--

- This whole approach is colloquially known as “ggploting”  

--

- Resulting figures are sometimes affectionately called “ggplots”  

--

**ggplot2** benefits from a wide variety of supplementary R packages that extends its functionalities, such as **gganimate**, **ggthemr**, **ggdendro**, **gghighlight**, **ggforce**...  

.footnote[
Bonus question: What does the "gg” in these names represent?
]

???
- "gg" represents the “grammar of graphics” used to construct the figures 





---
# Syntax overview  

Build a plot object by “adding” commands on top of one another that specify plot layers and design elements  


--

The order of layers will usually look like this:

1) **"Open" the plot** with the `ggplot()` command and specify the dataset  

--

2) **"Map" data columns** to features of the plot such as axes, color, size, shape, fill, transparency  

--

3) **Add (`+`) “geom” layers** that visualize data geometrically as shapes  

--

4) **Modify "scales"**, such as a color scale or y-axis breaks  

--

5) **Add design elements** such as axis labels, title, caption, fonts, text sizes, background themes, or axes rotation  

--

These layers are "added" sequentially with `+` symbols.  
**ggplot2** commands can be quite long!  


???
Remember that although the commands may be long, it is infinitely easier to edit and recycle than in Excel  







---
# Syntax - open the plot  

.pull-left[

`ggplot()` creates an empty canvas. Assign the data frame to use.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)                   
```

Alternatively, use the `%>%` pipe operator to "pipe" a data frame *into* `ggplot()`  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
linelist %>%
  ggplot()
```

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist)
```
] 

???
This is only a blank canvas, we have not defined what should be in the x and y axes. 
If several data frames are needed, they can be added in their own geoms.
Piping is useful to make one-time changes to a dataset prior to plotting.  



---
# Mappings with `aes()`  

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)
)
```

`mapping = aes()` is a `ggplot()` argument that assigns plot "aesthetics" to columns in the data. It is special in that its inputs must be placed within `aes()`.  

"Aesthetics" are features *whose display could vary for each data point* (position, color, shape...)  

Two core aesthetic mappings are assigning columns for axes positioning: `x=` and `y=`.  


]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))
```
] 



---
# Add geometry  

.pull-left[

```{r eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp))+
*geom_point()
```

Data are visualized using "geom" commands, such as `geom_point()`.  

These commands are "added" with a `+` to the `ggplot()` command.  

]


.pull-right[

```{r eval=T, echo=F, message=F, warning=F}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp))+
geom_point()
```

]




---
# Geometries  

.pull-left[

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`
Points          |`geom_point()`  
Lines           |`geom_line()`  
Box plots       |`geom_boxplot()`  
Bar charts      |`geom_bar()` or `geom_col()`  
Trend lines     |`geom_smooth()`  

Full list [here](https://ggplot2.tidyverse.org/reference/)  

]


.pull-right[

```{r, message=F, warning=F}

# Histogram
histogram <- ggplot(
    data = linelist,
    mapping = aes(
      x = date_onset))+
  geom_histogram(fill = "darkorange")+
  labs(title = "geom_histogram()")+
  theme_minimal()
  

points <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_hosp)
    )+
  geom_point()+
  labs(title = "geom_point()")+
  theme_minimal()


smooth <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_onset_hosp)
    )+
  geom_smooth()+
  labs(title = "geom_smooth()")+
  theme_minimal()



density <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_hosp)
    )+
  geom_density2d_filled()+
  labs(title = "geom_density2d_filled()")+
  theme_minimal()

  
lines <- linelist %>% 
  group_by(eth_race,
           week_report = lubridate::floor_date(date_report, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_report) %>% 
  ggplot(
    mapping = aes(
      x = week_report,       
      y = n_cases,
      color = eth_race),
    size = 4
    )+
  geom_line()+
  labs(title = "geom_line()")+
  theme_minimal()



boxplots <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = age)
    )+
  geom_boxplot()+
  labs(title = "geom_boxplot()")+
  theme_minimal()



violins <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = days_hosp,
      fill = died)
    )+
  geom_violin()+
  labs(title = "geom_violin()")+
  theme_minimal()


bars <- linelist %>% 
  ggplot(mapping = aes(
      y = died,
      fill = died))+
  geom_bar()+
  labs(title = "geom_bar()")+
  theme_minimal()+
  theme(legend.position = "none")


top <- cowplot::plot_grid(histogram, points,
                          boxplots, bars,
                          #smooth, density,
                          
                          nrow = 2, rel_widths = c(2,2))

cowplot::plot_grid(top, lines, ncol = 1)

```

]







---
# A quick note on indentations  

Indentations, spaces, and newlines do not impact code execution, and can be varied to improve readability.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist, mapping = aes(x = age, y = days_hosp))+
  geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(x = age, y = days_hosp))+
  geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,        # use case linelist
  mapping = aes(          # make aesthetic mappings for all geoms
    x = age,              # assign x-axis to age column
    y = days_hosp))+      # assign y-axis to duration of hospitalization
geom_point()              # display data as points
```



???
- Explain why you might use one or the other 
long style can enable informative comments/annotations  










---
# Aesthetic mapping placement  

* Mappings written in `ggplot()` apply to all geoms (e.g. axes)  
* Mappings written within one geom apply only to it  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(                     # open the plot 
  data = linelist,            # set dataset 
* mapping = aes(              # map axes to columns
*   x = age,
*   y = days_hosp))+
  geom_point()              # plot points
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)+    # open plot and set dataset
  geom_point(               # plot points
*    mapping = aes(           # map axes to columns
*      x = age,
*      y = days_hosp))
```

(but only because there is only one geom)  


???
- Explain why you might use one or the other  








---
# Adding geoms  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))+
*  geom_point()
```

With axes now mapped, the `geom_point()` displays the data as points.  

But... trends are difficult to interpret because points may be overlapping.  

]

.pull-right[


```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))+
  geom_point()
```

] 











---
# Adding geoms  

.pull-left[


```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))+
  geom_point()+
* geom_smooth()
```

Additional geoms can be added on top.  

`geom_smooth()` gives smoothed conditional means, helping to show trends in presence of "over-plotting" (see [documentation](https://ggplot2.tidyverse.org/reference/geom_smooth.html)).  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp))+
  geom_point()+
  geom_smooth()
```
] 

???
- Explain why you might use one or the other  






---

class: medium-large-table

# Other aesthetics  

.pull-left[
Aside from axes, other common "aesthetics" include: 

Geometry        |Geom                
----------------|--------------------
`shape = `      |Display point as dot, star, triangle, square...
`fill =  `      |The *interior* color (e.g of bar or boxplot)  
`color = `      |The *exterior* or bar, boxplot - OR point color  
`size = `       |Line thickness, point size...
`alpha = `      |Transparency (1 = opaque, 0 = invisible)
`width = `      |Width of "bar plot" bars
`linetype = `   |Either solid, dashed, dotted, etc.  
`binwidth = `   |Width of histogram bins  
  

]


.pull-right[

For color & fill use names or hex code  

```{r, eval = TRUE, echo = FALSE, out.height="80%"}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/ggplot_colors.png?raw=true")
```


.footnote[[Source](https://www.r-graph-gallery.com/ggplot2-color.html)
]

]

???

Note that “aesthetic” in ggplot has a specific meaning that you might associate with the word “aesthetics” in common English. In ggplot those details are called “themes” and are adjusted within a theme() command

Each geom accepts certain aesthetics, like `binwidth=` for `geom_histogram()`




---

class: medium-large-table

# Other aesthetics  

.pull-left[
Aside from axes, other common "aesthetics" include: 

Geometry        |Geom                
----------------|--------------------
`shape = `      |Display point as dot, star, triangle, square...
`fill =  `      |The *interior* color (e.g of bar or boxplot)  
`color = `      |The *exterior* or bar, boxplot - OR point color  
`size = `       |Line thickness, point size...
`alpha = `      |Transparency (1 = opaque, 0 = invisible)
`width = `      |Width of "bar plot" bars
`linetype = `   |Either solid, dashed, dotted, etc.  
`binwidth = `   |Width of histogram bins  
  

]


.pull-right[

For shapes, try these numeric codes:  

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/ggplot_shapes.png?raw=true")
```


.footnote[[Source](http://www.sthda.com/english/wiki/ggplot2-point-shapes)]

]



???

Note that “aesthetic” in ggplot has a specific meaning that you might associate with the word “aesthetics” in common English. In ggplot those details are called “themes” and are adjusted within a theme() command

Each geom accepts certain aesthetics, like `binwidth=` for `geom_histogram()`






---

class: medium-text

# Aesthetics assignments  


.pull-left[

These aesthetics can be assigned to either:  

* **Static values** (`color = "yellow"`)  
  - Assigned *outside* `aes()`  

* **A data column** (`aes(fill = died)`)  
  - Assigned *inside* `aes()`
  - Displays data as "groups"  
  

]


.pull-right[

Some examples:  

```{r, message=F, warning=F}

shape_3 <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(shape = 3)+
  theme_minimal()+
  labs(title = "shape = 3")

shape_died <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(aes(shape = died))+
  theme_minimal()+
  labs(title = "aes(shape = died)")

###

fill_purple <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(fill = "purple")+
  theme_minimal()+
  labs(title = "fill = 'purple'")


fill_died <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(aes(fill = died))+
    theme_minimal()+
  labs(title = "aes(fill = died)")

###

col <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(fill = "lightgreen", color = "purple")+
  theme_minimal()+
  labs(title = "fill = 'lightgreen', color = 'purple'")


col_died <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(aes(fill = died), color = "black")+
  theme_minimal()+
  labs(title = "aes(fill = died), color = 'black'")


cowplot::plot_grid(shape_3, shape_died,
                  fill_purple, fill_died,
                   col, col_died,
                   ncol = 2, rel_widths = c(2,2))


```

]







---
# Static aesthetics  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp))+ 
*geom_point(color = "seagreen")
```


An aesthetic is *static*, applying the same display to all data points, if it is assigned to a number or character value and written *outside* `aes()`.  

Other examples:  
`size = 3`  
`transparency = 0.5`  
`width = 1.2`  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
     x = age,
     y = days_hosp))+
geom_point(color = "seagreen")
```
] 






---
# Dynamic aesthetics   

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
*   color = died))+
geom_point()
```


An aesthetic is *dynamic*, varying for each data point, if it assigned to a *column name* and written *inside* an `aes()`.  

Above, `color=` is mapped to column `died`, and is inherited by `geom_point()`. This create "groups" in the plot and generates a legend.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died))+   
geom_point()
```
]

???




---
# Multiple aesthetics - example  

.pull-left[


```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
*   color = died))+   # color by outcome
*geom_point(size = 7) # all points 7x size 
```

Above, `size = 7` is a static aesthetic - it is not within any `aes()` function and therefore is not mapped to any column.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died))+ # color varies by outcome
geom_point(size = 7) # all points 7x size      
```
]

???

As there is only one geom, all aesthetics can be writtein `ggplot()`, or in `geom_point()`




---
# A common error  

.pull-left[

Aesthetic mappings like `fill=` and `color=` create "groups" in the plot. Problems arise if your summarise your data "by group" but plot indescriminately - resulting in multiple y values per x value.  

Below, `outcome_time_data` has one row per unique week-outcome.  


```{r, eval=F, echo = T, warning=F, message=F}
outcome_time_data <- linelist %>% 
  group_by(died,
           week_onset = lubridate::floor_date(date_onset, "week")) %>% 
  summarise(n_cases = n()) %>%

  select(week_onset, everything()) %>% 
  arrange(week_onset) %>% 
  drop_na(week_onset)
```
]


.pull-right[
First 6 rows:  

```{r, eval=T, echo = F, warning=F, message=F}
outcome_time_data <- linelist %>% 
  group_by(died,
           week_onset = lubridate::floor_date(date_onset, "week")) %>% 
  summarise(n_cases = n()) %>%

  select(week_onset, everything()) %>% 
  arrange(week_onset) %>% 
  drop_na(week_onset)

outcome_time_data %>%
  head() %>% 
  knitr::kable()
```

]



---
# A common error  

.pull-left[

```{r, echo=T, eval=F}
# Forgot to include an aesthetic mapping to create groups!
ggplot(
  data = outcome_time_data,
  mapping = aes(
    x = week_onset,       
    y = n_cases))+
  geom_line()+
  labs(title = "Weekly cases, by outcome (?)")
```

Above, the column `died` is not provided to any grouping argument, such as `color=`.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = outcome_time_data,
  mapping = aes(
    x = week_onset,       
    y = n_cases))+
  geom_line()+
  labs(title = "Weekly cases, by outcome (?)")

```
]



---
# A common error - resolved  

.pull-left[

```{r, echo=T, eval=F}
ggplot(
  data = outcome_time_data,
  mapping = aes(
    x = week_onset,       
    y = n_cases,
*   color = died))+
  geom_line()+
  labs(title = "Weekly cases, by outcome")
```

Use aesthetic mappings like `fill` or `color` to visualise "groups" in the plot.  

This version includes `color=` mapped to the `died` column.

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = outcome_time_data,
  mapping = aes(
    x = week_onset,       
    y = n_cases,
    color = died))+
  geom_line()+
  labs(title = "Weekly cases, by outcome")


```
]



---
# Facets/small-multiples


.pull-left[

Another way of displaying groups is via faceting.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(~eth_race)
```

] 



.pull-right[
```{r }
ggplot(data = linelist,
       mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_wrap(~ eth_race)
```

]



---
# Facets/small-multiples

.pull-left[

"Free" axes by setting `scales=` to "free_y", "free_x", or "free".  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(~ eth_race, scales = "free_y") #<<
```

] 

.footnote[
Alert your audience if you free an axis! Also, try `ncol=` and `nrow=`. 
]


.pull-right[
```{r }
ggplot(data = linelist,
       mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_wrap(~ eth_race, scales = "free_y")
```

]




---
# Facets/small-multiples


.pull-left[

To generate one graph per race/ethnicity AND gender:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(gender ~ eth_race) 
```

The "~" signifies "by"  

] 

By using `facet_wrap()` the plots appear sequentially by alphabet/factor level. Facet titles are combined.  


.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
facet_wrap(gender ~ eth_race)
```

]




---
# Facets/small-multiples


.pull-left[

Try `facet_grid()` to show two variables in a grid. Note the labels along the sides.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_grid(gender ~ eth_race) 
```

] 


.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
facet_grid(gender ~ eth_race)
```

]


---
# Facets/small-multiples


.pull-left[

You can `filter()` or `drop_na()` in advance, to remove undesired levels  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
linelist %>% 
  drop_na(gender, eth_race) %>% 
  filter(gender != "Unknown") %>% 
  
  # begin plot
  ggplot(
    mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_grid(gender ~ eth_race) 
```

Note above we pipe the adjusted data frame into `ggplot()`, for ease 
] 


.pull-right[
```{r }
linelist %>% 
  drop_na(gender, eth_race) %>% 
  filter(gender != "Unknown") %>% 
  
  ggplot(
    mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_grid(gender ~ eth_race)
```

]



---
# Facets + `gghighlight()`

.pull-left[

Add `gghighlight()` from **gghighlight** to show a full "shadow" behind each plot. For color add the `aes(fill=)`.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = date_onset,
*   fill = eth_race)) +
geom_histogram() +
facet_wrap(~ eth_race)+
*gghighlight::gghighlight()
```

] 

.footnote[
Try `gghighlight()` with other plots! 
]


.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(
    x = date_onset,
    fill = eth_race)) +
geom_histogram() +
facet_wrap(~ eth_race)+
gghighlight::gghighlight()
```

]





---
# gghighlight

.pull-left[

Add `gghighlight()` to other plots, and specify specific values (or criteria) to highlight 

```{r, echo=T, eval=F}
linelist %>% 
  # get daily counts by zip code
  group_by(age_group, date_report) %>%
  count() %>% 
  
  # plot
  ggplot(
    mapping = aes(
      x = date_report,
      y = n,
      color = age_group))+
  geom_line()+
* gghighlight::gghighlight(age_group %in% c("40-49", "60-69)"))+
  theme(legend.position = "none")
  
```




] 


.pull-right[
```{r echo=F, eval=T}
linelist %>% 
  # get daily counts by zip code
  group_by(age_group, date_report) %>%
  count() %>% 
  
  # plot
  ggplot(
    mapping = aes(
      x = date_report,
      y = n,
      color = age_group))+
  geom_line()+
  gghighlight::gghighlight(age_group %in% c("40-49", "60-69"))+
  theme(legend.position = "none")
```

]




---
# Scales - overview  

Scale commands control *how* the aesthetic mappings manifest, for example:  
* *Which* colors or shapes to display  
* The min/max of point sizes  
* The min/max and frequency of axes breaks  

To replace the defaults, add a `scale_` command. As a generic formula, these commands are written as: `scale_AESTHETIC_METHOD()`.  

1) `scale_` : this prefix never changes  
2) Aesthetics like: `_fill_` , `_color_` , `_x_` , `_y_` , etc.  
3) Methods like: `_continuous()`, `_discrete()`, `_manual()`, `_date()` etc.

Inside the command, use arguments such as `breaks=`, `values=`, or `labels=` (there are many possibilities).  


---
# Scales examples  

Some examples of scale commands:  

You want to adjust  |Scale command
--------------------|-------------------
continuous y-axis   |`scale_y_continuous()`
date x-axis         |`scale_x_date()`  
categorical x-axis  |`scale_x_discrete()`  
fill, continuous    |`scale_fill_continuous()`
fill, continuous    |`scale_fill_gradient()`  
color, manual assign|`scale_color_manual()`  




---
# Scales - default 

.pull-left[

```{r, eval=F, echo=T}
ggplot(linelist)+
  geom_bar(aes(x = eth_race, fill = died))
```


Above, the fill of a bar plot uses the **default colors and axis breaks**:  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+
  geom_bar(aes(x = eth_race, fill = died))+
  theme_gray(base_size = 18)
```

]



---
# Scales - adjusted fill 

.pull-left[


```{r, eval=F, echo=T}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
*scale_fill_manual(        
*  values = c("Yes"    = "violetred", 
*             "No"     = "aquamarine",
*            "Unknown" = "grey"))

#use na.value = "grey"  for missing values
```


Adding `scale_fill_manual()`, we list the color assignments in a vector `c()`.   


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey"))+
theme_gray(base_size = 18)
```
]

???
Discuss the na.value= arguments in most scale commands, and the difference between having NA values in the data and having an explicit missing value such as "Unknown".


---
# Scales - adjusted y-axis 

.pull-left[

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey"))+
*scale_y_continuous(
*  breaks = seq(from = 0,
*               to = 35000,
*               by = 5000))
```

Then, in `scale_y_continuous()` we adjust the y-axis breaks using `seq()` to define a numeric sequence.   

]

.pull-right[

```{r}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey"))+
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000))+
theme_gray(base_size = 18)
```

]





---
# Scales - "Floating plots" 

.pull-left[

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey"))+
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
* expand = c(0,0))+
*scale_x_discrete(
*  expand = c(0,0))
```

In any `scale_x_` or `scale_y_` command, use `expand = c(0,0)` to remove excess space around the plot features.  

]

.pull-right[

```{r}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey"))+
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
  expand = c(0,0))+
scale_x_discrete(
  expand = c(0,0))+
theme_grey(base_size = 18)
```

]




---
# Scales - date axis

.pull-left[

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))
```

Default scale of date axes reflect the range of your data, and will vary in formal.  

]

.pull-right[

```{r}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
theme_grey(base_size = 18)

```

]







---
# Scales - date axis breaks

.pull-left[


```{r, eval=F, echo=T}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
*scale_x_date(
*  date_breaks = "3 months")

```

Adjusted with `scale_x_date()`, which offers special arguments `date_breaks=` and `date_labels=`.  

Specify break intervals using values like "1 week", or "2 weeks", or "3 months". Note these are the *axis* breaks, not the histogram bins!  

.footnote["weeks" start on Mondays. See Epi R Handbook epicurves page for alternatives.]

]

.pull-right[

```{r}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
scale_x_date(
  date_breaks = "3 months"
)+
theme_grey(base_size = 18)

```

]

???
For tips on geom_histogram() bins, see Epi R Handbook epicurves page


---
# Scales - date axis labels

.pull-left[

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
scale_x_date(
  date_breaks = "3 months",
* date_labels = "%d %b\n%Y")  # \n is a newline

```

Specify date format to `date_labels=` using "strptime" syntax ([link](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/strptime)) like `"%d %b %Y"` for DD MMM YYYY.  


See Epi R Handbook [Epicurves](https://epirhandbook.com/epidemic-curves.html) and [Strings](https://epirhandbook.com/characters-and-strings.html) pages for more tips

]

.pull-right[

```{r}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
scale_x_date(
  date_breaks = "3 months",
  date_labels = "%d %b\n%Y"
)+
theme_grey(base_size = 18)

```

]





---
# Labels  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)+
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3)+
*labs(
*  title = "Duration of admission among hospitalized COVID-19 patients",
*  x = "Age (years)",
*  y = "Duration (days)",
*  caption = "Fictional COVID-19 data",
*  color = "Deceased"
)
```

Use `lab()` to edit title, subtitle, caption, axes labels, and legend title  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist)+
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3)+
labs(
  title = "Duration of admission among hospitalized COVID-19 patients",
  x = "Age (years)",
  y = "Duration (days)",
  caption = "Fictional COVID-19 data",
  color = "Deceased"
)+
theme_grey(base_size = 18)
```
]



---
# Label tips  

See the [Epi R Handbook page](https://epirhandbook.com/characters-and-strings.html#dynamic-strings) on adjusting characters with the **stringr** package

**New lines**  
Use `\n` within the string to bump to a new line, or place the text in [`str_wrap()`](https://stringr.tidyverse.org/reference/str_wrap.html)

```{r, eval=F, echo=T}
title = "Top line\nNextline"                        # \n creates new line
title = str_wrap("This is a really long title", 30) # wrap at 30 characters
```


**Dynamic labels**  
Use `str_glue()` to imbed R code that updates with the data.  

```{r, eval=F, echo=T}
caption = str_glue("Data as of {Sys.Date()}")
```

```{r, eval=F, echo=T}
caption = str_glue("{nrow(linelist %>% filter(is.na(date_onset)))} cases missing date of onset and not shown")
```

**Legend title**  
In `labs()`, write the aesthetic that created the legend, like `fill=`, `color=`, or `shape=`, and provide a title.  



???
Explain that in str_glue, anything within curly brackets it will run as R code.  


---
# Themes  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
     title = "Duration of admission among\nhospitalized COVID-19 patients",
     x = "Age (years)",
     y = "Duration (days)",
     caption = "Fictional COVID-19 data",
     color = "Deceased")+
* theme_minimal(base_size = 18)
```


Themes are non-data plot features (background, text side/color, etc).  

[These "complete themes"](https://ggplot2.tidyverse.org/reference/ggtheme.html) are easy to add.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "Duration of admission among\nhospitalized COVID-19 patients",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data",
    color = "Deceased")+
  theme_minimal(base_size = 18)
```
]

???
Others include theme_grey, theme_classic, etc... adjust base text size.







---
# Themes  

.pull-left[

Themes are non-data plot features (background, text side/color, etc).  

[These "complete themes"](https://ggplot2.tidyverse.org/reference/ggtheme.html) are easy to add.  

```{r, eval=F, echo=T}
# Try one of these...
theme_bw()+
theme_classic()+
theme_dark()+
theme_gray()+
theme_minimal()+
theme_light()+
theme_void()+
```
]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}

minimal <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_minimal()",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data")+
  theme_minimal(base_size = 18)



bw <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_bw()",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data")+
  theme_bw(base_size = 18)



grey <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_grey()",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data")+
  theme_grey(base_size = 18)


dark <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_dark()",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data")+
  theme_dark(base_size = 18)



void <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_void()",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data")+
  theme_void(base_size = 18)



light <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_light()",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data")+
  theme_light(base_size = 18)


themes_plots <- cowplot::plot_grid(
  minimal, light,
  bw, grey,
  dark, void,
  nrow = 3, rel_widths = c(2,2))

themes_plots

```



]






---
# Syntax - micro-adjust theme  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age, y = days_hosp, color = died),    
    alpha = 0.3)+
geom_point()+
labs(
  title = "Duration of admission among\nhospitalized COVID-19 patients",
  x = "Age (years)", y = "Duration (days)",
  caption = "Fictional COVID-19 data",
  color = "Deceased")+
theme_minimal(base_size = 14)+
*theme(
* legend.position = "bottom",
* plot.title = element_text(color = "red",
*                           face = "bold"),
* axis.title.y = element_text(angle = 90))
```


Use `theme()` and [this list](https://ggplot2.tidyverse.org/reference/theme.html) of feature-specific arguments.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "Duration of admission among\nhospitalized COVID-19 patients",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data",
    color = "Deceased")+
  theme_minimal(base_size = 18)+
  theme(
    legend.position = "bottom",
    plot.title = element_text(color = "red",
                              size = 20,
                              face = "bold"),
    axis.title.y = element_text(angle = 0))
```
]

???
Talk about these theme() arguments and how they consist of two parts, just like `mapping = aes()`. 
Explain that nobody has these all memorized, but the common ones are easy to remember once you use them enough.  
Remember to add them AFTER any complete themes.





---
# Make an epidemic curve  

Two approaches that we suggest:  

1) Use the **incidence2** package  
  * Fast, simple, and modifiable with ggplot additions  
  
2) Use ggplot's `geom_histogram()`  
  * Most customizeability  
  * Most complex code  

--

Today's demonstration will focus on **incidence2**.  

.footnote[See the Epi R handbook's [Epicurves page](https://epirhandbook.com/epidemic-curves.html) for detailed examples of both methods]  










---
# Epicurve - make incidence object 

.pull-left[

Load **incidence2**  

```{r, echo=T, eval=F}
pacman::p_load(incidence2) # install/load
```

**Create** an incidence object from your dataset  

```{r, echo=T, eval=F}
weekly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "week")       # bin interval   
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly)
```
]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
weekly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "week")       # bin interval   

plot(weekly)
```

]




---
# Epicurve - incidence object 

.pull-left[

Adjust the interval

```{r, echo=T, eval=F}
bimonthly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
* interval = "2 months")   # bin interval   
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(bimonthly)
```

Try "Sunday weeks" or "MMWR week" for Sunday weeks.  

]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
bimonthly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "2 months")       # bin interval   

plot(bimonthly)
```

]




---
# Epicurve - groups 

.pull-left[

To add groups, specify them to `groups=` in the `incidence()` command:  

```{r, echo=T, eval=F}
weekly <- incidence(
  x = linelist,              # define dataset
  date_index = date_onset,   # date column
  interval = "weeks",        # bin interval
* groups = eth_race)      
```

AND to `fill=` in the `plot()` command:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly,
* fill = eth_race)
```

If grouping by multiple columns, nest them in both places within `c()`:  

```{r, eval=F, echo=T}
groups = c(eth_race, gender)
```

]

.pull-right[



```{r, echo=F, eval=T}
weekly <- incidence(
  x = linelist,              # define dataset
  date_index = date_onset,   # date column
  interval = "weeks", # bin interval
  groups = eth_race) 

plot(weekly,
  fill = eth_race)
```

]









---
# Epicurve - groups 


.pull-left[

Add other **ggplot2** commands with `+`.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly, fill = eth_race)+
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250))+
*scale_y_continuous(
* expand = c(0,0),
* breaks = seq(0,2000,250))+
*theme(legend.position = "top")+
*labs(fill = "Race and\nEthnicity")
```

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly,
  fill = eth_race)+
scale_y_continuous(expand = c(0,0),
                   breaks = seq(0,2000,250))+
theme(legend.position = "top")+
labs(fill = "Race and\nEthnicity")
```

]




---
# Epicurve - date axis 

.pull-left[

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly,
  fill = eth_race,
*  date_format = "%a %d %b %Y\n (Week %W)", 
*  angle = 30)+                           # angle of date labels)+
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250))+
theme(legend.position = "top")+
labs(fill = "Race and\nEthnicity")
```


Do adjust date axis with `scale_x_date()`. Instead, use custom **incidence2** arguments in `plot()`.  

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly,
  fill = eth_race,
  date_format = "%a %d %b %Y\n (Week %W)", 
  angle = 30)+                           # angle of date labels)+
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250))+
theme(legend.position = "top")+
labs(fill = "Race and\nEthnicity")
```

]








---
# Epicurve - show cases 

.pull-left[

For small outbreaks, the style `show_cases = TRUE` may be helpful:  

```{r, eval=F, echo=T, warning=F, message=F}
small_outbreak <- linelist %>% 
  filter(zip == 30024,
         date_report >= as.Date("2020-12-01")) %>% 
  incidence(
    # data set is piped in from above
    date_index = date_onset,               
    interval = "Sunday weeks",             
    groups = eth_race)
```

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(small_outbreak,
  fill = eth_race,
* show_cases = TRUE)+
theme(legend.position = "bottom")+
labs(title = "COVID-19 cases in ZIP 30024 from Dec 2020, by race/ethnicity")
```

]

.pull-right[

```{r, echo=F, eval=T}
small_outbreak <- linelist %>% 
  filter(zip == 30024,
         date_report >= as.Date("2020-12-01")) %>% 
  incidence(
    # dataset is piped in from above
    date_index = date_onset,               
    interval = "Sunday weeks",             
    groups = eth_race)

plot(small_outbreak,
  fill = eth_race,
 show_cases = TRUE)+
theme(legend.position = "bottom")+
labs(title = "COVID-19 cases in ZIP 30024 from Dec 2020, by race/ethnicity")
```

]









---
# Epicurve - color palette 

.pull-left[

Try an **incidence2** color palette  


```{r, echo=T, eval=F}
plot(weekly,
  fill = eth_race, 
* col_pal = muted)
```

Note a palette is an *object* and so not in quotes.  

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly,
  fill = eth_race, 
  col_pal = muted)
```



]

???
This uses the build-in argument from incidence2 to accept color palettes.








---
# Epicurve - color palette 

.pull-left[

Add `scale_fill_viridis_d()` for palettes that are color-blind friendly:  

```{r, echo=T, eval=F}
plot(weekly, fill = eth_race)+
*scale_fill_viridis_d(
    option = "inferno",            # color scheme, try also "plasma" or default
    name = "Race and\nEthnicity",  # legend name
    na.value = "grey")             # for missing values
```

[Viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) (try with `option = "plasma"` or "inferno"), and [colorbrewer](https://www.r-graph-gallery.com/38-rcolorbrewers-palettes.html) palette functions can be added to any ggplot as well.  

.footnote[The `_d()` indicates a scale for discrete values]  

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly, fill = eth_race)+
   scale_fill_viridis_d(
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values
```


]



---

# Epicurve - aggregated counts  



.pull-left[

You can also use **incidence2** on data that are aggregated counts...  

```{r, eval=T, echo=F}
# For demo: aggregate linelist
# create daily counts
linelist_day_counts <-linelist %>% 
  count(day = floor_date(date_report, "day"),
        died) %>% 
  drop_na(day)
```

]

.pull-right[
A few rows:  

```{r, eval=T, echo=F}
linelist_day_counts %>% 
  tail(10) %>% 
  knitr::kable()
```

]



---

# Epicurve - aggregated counts  

.pull-left[

```{r, eval=F, echo=F}
died_curve <- incidence(  
  linelist_day_counts,  # dataset with counts aggregated by day
  date_index = day,     # column with dates
  count = n,            # column with counts
  interval = "week",    # aggregate daily counts up to weeks
  groups = died         # group by outcome
  )
```

```{r, eval=F, echo = T}
# plot the weekly incidence epi curve, with stacked bars by outcome
plot(died_curve,    # incidence object
     fill = died)   # color the bars by outcome
```

]

.pull-right[

```{r, eval=T, echo=F}
died_curve <- incidence(   
  linelist_day_counts,   # dataset with counts aggregated by day
  date_index = day,      # column with dates
  count = n,             # column with counts
  interval = "week",     # aggregate daily counts up to weeks
  groups = died          # group by outcome
  )
```

```{r, eval=T, echo=F}
# plot the weekly incidence epi curve, with stacked bars by hospital
plot(died_curve,         # incidence object
     fill = died)        # color the bars by outcome
```

]


---
# Demographic pyramids  

We suggest two ways to make age pyramids:  

1) Use the **apyramid** package - simple, easy  

2) Use **ggplot2** - more customizeable, but opportunity for error  

--

Today we will demonstrate **apyramid**.  

.footnote[See the Epi R Handbook [page on demographic pyramids](https://epirhandbook.com/demographic-pyramids-and-likert-scales.html) for more information on both.]  



---
# Demographic pyramids

The function `age_pyramid()` from **apyramid** offers an easy interface:  

.pull-left[

```{r, echo=F, eval=T}
linelist <- linelist %>% 
  mutate(
    gender = na_if(gender, "Unknown"), # convert to NA 
    gender = fct_drop(gender))         # drop unused factor levels
```

```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender")
```

.footnote[We have cleaned `gender` to only two values]  


]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender")
```

]



---
# Demographic pyramids

.pull-left[

Further modifications:  

* Percents instead of raw counts on the x-axis  
* No mid-point designation  
* Specified colors  

```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
* proportional = TRUE,
* show_midpoint = FALSE,
* pal = c("darkgreen", "brown")) # colors only, not legend labels
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE,
  pal = c("darkgreen", "brown"))
```

]


---
# Demographic pyramids

You can add further ggplot commands 

.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE)+
*theme_minimal()+
*labs(
*  title = "Age and Gender of COVID-19 cases",
*  subtitle = "Fulton County, GA",
*  x = "Percent of total",
*  y = "Age group",
*  fill = "Gender",
*  caption = "Caption here")
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE)+
theme_minimal()+
labs(
  title = "Age and Gender of COVID-19 cases",
  subtitle = "Fulton County, GA",
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
  caption = "Caption here")
```

]



---
# Dynamic labels example

Let's use these dynamic labels for the demographic pyramid, so that they will update with the data.  

For complicated `str_glue()` cases, define the dynamic components outside the quotation marks.  

**Caption**  
```{r, eval=F, echo=T}
labs(caption = str_glue(
  "{missing} cases missing either age or gender are not shown.",
  missing = linelist %>%
            filter(is.na(gender) | is.na(age_group)) %>% 
            nrow()
  ))
```

.footnote[Note you can make data missing age appear at pyramid top with `na.rm = FALSE`]


---
# Dynamic labels example

Let's use these dynamic labels for the demographic pyramid, so that they will update with the data:  

**Subtitle**  
```{r, eval=F, echo=T}
labs(
  subtitle = str_glue(
    "Fulton County, GA, reported {min_date} - {max_date}",
  
    min_date = format(min(linelist$date_report, na.rm=T), "%B %d %Y"),
  
    max_date = format(max(linelist$date_report, na.rm=T), "%B %d %Y")
  )
) 
```




---
class: remark-code

# Dynamic captions

Now applying those dynamic captions:  

.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE)+
theme_minimal()+
labs(
  title = "Age and Gender of COVID-19 cases",
  subtitle = str_glue(
    "Fulton County, GA, reported {min_date} - {max_date}",
  
    min_date = format(
      min(linelist$date_report, na.rm=T),
      "%B %d %Y"),
  
    max_date = format(
      max(linelist$date_report, na.rm=T),
      "%B %d %Y")
  ),
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
  caption = str_glue(
    "{missing} cases missing either age or gender are not shown.",
    missing = linelist %>%
              filter(is.na(gender) | is.na(age_group)) %>% 
              nrow())
  )
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE)+
theme_minimal()+
labs(
  title = "Age and Gender of COVID-19 cases",
  subtitle = str_glue(
  "Fulton County, GA, reported {min_date} - {max_date}",
  
  min_date = format(
    min(linelist$date_report, na.rm=T),
    "%b %d %Y"),
  
  max_date = format(
    max(linelist$date_report, na.rm=T),
    "%b %d %Y")
  ),
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
  caption = str_glue(
    "{missing} cases missing either age or gender are not shown.",
    missing = linelist %>%
              filter(is.na(gender) | is.na(age_group)) %>% 
              nrow())
  )
```

]




---
# Bar plots  

`geom_col()` and `geom_bar()` are used to make general bar plots (non-epicurves).

--

Use `geom_bar()` if bar height should reflect the number of rows in the data (e.g. a case linelist).  

```{r, echo=T, eval=F}
ggplot(linelist)+                        # begin with linelist       
*  geom_bar(mapping = aes(x = eth_race)) # one bar per race/ethnicity. No y= argument. 
```

--

Use `geom_col()` if the data have a numeric column containing the desired bar height (i.e. aggregated count data).  

```{r, eval=F, echo=T}
ggplot(linelist_agg)+                             # begin with aggregated count data            
*  geom_col(mapping = aes(x = eth_race, y = n))   # bar height is value in column "n"
```





---
# Bar plot - a common error 

.pull-left[

If your data look like this (counts) and your plot looks like that (bars of same height), ensure you are using `geom_col()` and not `geom_bar()`!  

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  knitr::kable()
```

]

.pull-right[

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  ggplot()+
  geom_bar(
    mapping = aes(x = eth_race))
```

This plot shows that there is one row per ethnicity/race!  

]

 




---

class: medium-table

# Bar plot - count rows  

.pull-left[

With `geom_bar()`, the height reflects the number of rows per x-axis group. This works well for linelist data.  

```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist)+             
  geom_bar(           # height is num of rows
    mapping = aes(    # aesthetic mappings
      x = eth_race))  # one bar per ethnicity
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(          # column height by number of rows
    mapping = aes(
      x = eth_race)) # one bar per race/ethnicity. No y= argument. 
```
]

---

class: medium-table

# Bar plot - count grouped rows  

.pull-left[

To achieve "stacked" bars with `geom_bar()`, simply assign the group column to `fill =`, within `aes()`  

```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist)+             
  geom_bar(           # height is num of rows
    mapping = aes(
      x = eth_race,   # one bar per ethnicity.
      fill = died))   # stack by col "died" 
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(           # column height by number of rows
    mapping = aes(
      x = eth_race,        # one bar per ethnicity. No y= argument.
      fill = died))   # stack bars by column "died"  
```
]



---

class: medium-table

# Bar plot - counts  

.pull-left[

In contrast, `geom_col()` uses a column of counts, such as column `n` in this `linelist_eth` dataset:

```{r, eval=T, echo=F}
linelist_eth <- linelist %>% 
  count(eth_race)

linelist_eth %>% 
  head(6) %>% 
  knitr::kable()
```

Column `n` provides the bar height.    

```{r, echo=T, eval=F}
ggplot(linelist_eth)+ # use counts dataset             
*  geom_col(          # height by value
    mapping = aes(   
      x = eth_race,   # one per ethnicity.
*     y = n))         # y= for bar height    
```


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,           # one bar per ethnicity. No y= argument. 
    )
  )
```


]



---

class: medium-table

# Bar plot - stacked counts  

.pull-left[

To have "stacked" bars using `geom_col()`, each plotting group must have its own rows in the data. Use "long"-style data like below:  

```{r, echo = F, eval=T}
linelist_eth_died <- linelist %>% 
  count(eth_race, died)

linelist_eth_died %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist_eth_died)+ # use counts data              
  geom_col(                # height by value
    mapping = aes(
      x = eth_race,        # one bar per ethnicity 
      y = n,               # bar height from col "n"
      fill = died))        # stacked bars by outcome
```

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died)+ # begin with data aggregated by day/ethnicity              
  geom_col(               # column height by aggregated counts
    mapping = aes(
      x = eth_race,            # one bar per ethnicity. 
      y = n,              # bar height from column "n"
      fill = died))       # stacked bars by outcome
```

]



---
# Bar plots (flip axes)  

.pull-left[

It is simple to flip the axes on any ggplot by adding `coord_flip()`  


```{r, echo=T, eval=F}
ggplot(linelist)+        # begin with case linelist    
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,           # one bar per ethnicity. No y= argument. 
      fill = died))+     # stacked bars by outcome
* coord_flip()           # flip x and y axes
```


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,           # one bar per ethnicity. No y= argument. 
      fill = died))+     # divide into stacked bars by outcome
  coord_flip()           # flip x and y axes
```
]


---
# Bar plots (adjust order)  

.pull-left[

Use functions from the **forcats** package to convert the column to class *factor* and adjust the "levels".  

Changes can be made outside ggplot (a lasting change to the dataset), or inside (applies only to this plot).  

[1] See the Epi R Handbook page on [factors](https://epirhandbook.com/factors.html#within-a-plot). 

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,      # one bar per ethnicity. No y= argument. 
      fill = died))+     # divide into stacked bars by outcome
  coord_flip()           # flip x and y axes
```
]






---
# Bar plots (adjust order)  

.pull-left[

Below, to order by frequency, `fct_infreq()` is applied to the x-axis column `eth_race` and the fill column `died`.

```{r, echo=T, eval=F}
ggplot(linelist)+          # begin with case linelist    
  geom_bar(                # column height by number of rows
    mapping = aes(
*     x = fct_infreq(eth_race),  # bars ordered by frequency 
*     fill = fct_infreq(died)))+ # stacks ordered by frequency
 coord_flip()              # flip x and y axes
```

You will need to clean up the legend title now, with `labs(fill=)`.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = fct_infreq(eth_race),    # bars ordered by frequency 
      fill = fct_infreq(died)))+   # stacks ordered by frequency
  coord_flip()           # flip x and y axes
```
]




---
# Bar plots (reverse order)  

.pull-left[

To *reverse* bar order, use `fct_rev()` from the **forcats** package. It can be wrapped around other functions. 

The below reverses the previous frequency ordering from `fct_infreq()`.  


```{r, echo=T, eval=F}
ggplot(linelist)+              
  geom_bar(                
    mapping = aes(
*     x = fct_rev(fct_infreq(eth_race)),  # reverse frequency
*     fill = fct_rev(fct_infreq(died))))+ # reverse frequency      
 coord_flip()              
```

[1] See the Epi R Handbook page on [factors](https://epirhandbook.com/factors.html#within-a-plot). 
]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = fct_rev(fct_infreq(eth_race)),            
      fill = fct_rev(fct_infreq(died))))+     
  coord_flip()          
```

]





---


# Bar plot - display counts  

.pull-left[

To display text, add `geom_text()` with `aes(label=)` assigned to the height column.  

The `position=` arg in `geom_text()` can specify display at mid-bar.  

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died,
*   label = n))+             
geom_col()+
*geom_text(
* size = 3,
* position = position_stack(vjust = 0.5))
```

.footnote[
Best to use `geom_col()` and not `geom_bar()` for this. Also, try `geom_label()` if you want a box around the text.  
]

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died,
       aes(x = eth_race, y = n, fill = died, label = n))+             
  geom_col()+
  geom_text(size = 3, position = position_stack(vjust = 0.5))
```

]




---


# Bar plot - adjust width  

.pull-left[

Adjust bar width with `width=`.  

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died))+             
*geom_col(width = 0.5)+

```

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died,
       aes(x = eth_race, y = n, fill = died))+             
  geom_col(width = 0.5)
```

]

???
Be wary of adjusting width for date bars (e.g. month) - use `geom_histogram()` instead with bin breaks.  




---


# Bar plot - adjacent  

.pull-left[

To make the bars adjacent, specify `position = "dodge"` in `geom_col()`.  

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died,
    label = n))+             
* geom_col(position = "dodge")
```

.footnote[
Adjust the order with via a **forcats** function that adjusts factor levels.  
]

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died,
    label = n))+             
  geom_col(position = "dodge")
```

]



---


# Bar plot - adjacent with text  

.pull-left[

To display text on adjacent bars, add the `group=` argument in `aes()`, and adjust `geom_text(position=)` as below.  

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
*   group = died,
    fill = died,
    label = n))+             
  geom_col(position = "dodge")+
  geom_text(
    size = 3,
*   position = position_dodge(width = 1),
    vjust = -1)
```

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died,
    group = died,
    label = n))+             
  geom_col(position = "dodge")+
  geom_text(size = 3, position = position_dodge(width = 1), vjust = -1)

```

]




---


# Bar plot - flip axes  

.pull-left[

If flipping axes, you will need to manually adjust `hjust=` in `geom_text()` to meet your needs.  

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    group = died,
    fill = died,
    label = n))+             
  geom_col(position = "dodge")+
  geom_text(
    size = 3,
    position = position_dodge(width = 1),
*   hjust = -1)+
* coord_flip()    # flip axes
```

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died,
    group = died,
    label = n))+             
  geom_col(position = "dodge")+
  geom_text(size = 3, position = position_dodge(width = 1), hjust = 1)+
  coord_flip()

```

]






---

class: medium-table

# Labeling  


.pull-left[
 
To demonstrate labeling points, we create a new dataset that summarizes CFR and median age by race/ethnicity

```{r, echo=T, eval=T}
race_CFR_age <- linelist %>% 
  group_by(eth_race) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes", na.rm=T),
    CFR = deaths/cases,
    med_age = median(age, na.rm=T),
    med_dur = median(days_hosp, na.rm=T)
  )
```

]

.pull-right[

```{r, echo=F, eval=T}
head(race_CFR_age, 5) %>% 
  knitr::kable()
```
]








---

# Labeling  

.pull-left[
 
We can plot these data as points, and label them with `geom_text()`... but it does not look very good.  

```{r, echo=T, eval=F}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = eth_race))+
geom_point()+
*geom_text()
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = eth_race))+
  geom_point()+
  geom_text()
```

]









---

# Labeling  

.pull-left[
 
Labels look much improved by using `geom_label_repel()` from the **ggrepel** package:  

```{r, echo=T, eval=F}
library(ggrepel)

ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = eth_race))+     # text to display
geom_point()+
*geom_label_repel(         # add labels
*   size = 5,               # text size
*   min.segment.length = 0) # show connector lines
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = eth_race))+
  geom_point()+
 geom_label_repel(
    size = 5,
    min.segment.length = 0)
```

]








---

# Labeling  

.pull-left[
 
`labels=` can be assigned complex values with `str_glue()`:  

```{r, echo=T, eval=F}
library(ggrepel)

ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = str_glue("{eth_race}\n{cases} cases")))+
geom_point()+
geom_label_repel(
    size = 5,
    min.segment.length = 0)
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = str_glue("{eth_race}\n{cases} cases")))+
  geom_point()+
 geom_label_repel(
   size = 5,
   min.segment.length = 0)
```

]






---

# Labeling  

.pull-left[
 
Use `comma()` from the **scales** package to make numbers display with comma separators every three digits.  

```{r, echo=T, eval=F}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = str_glue("{eth_race}\n{scales::comma(cases)} cases")))+
geom_point()+
geom_label_repel(
    size = 4,
    min.segment.length = 0)
```

See the many other useful functions in [**scales**](https://scales.r-lib.org/).  

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = str_glue("{eth_race}\n{scales::comma(cases)} cases")))+
geom_point()+
geom_label_repel(
   size = 4,
   min.segment.length = 0)
```

]






---

# Animation  

https://gganimate.com/

.pull-left[
```{r, echo=T, eval=T}

zip <-  linelist %>% 
  group_by(
    zip,
    month = floor_date(date_report, "month")) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes", na.rm=T),
    CFR = deaths/cases,
    med_age = median(age, na.rm=T),
    med_dur = median(days_hosp, na.rm=T)
  ) %>% 
  drop_na(month)



race_CFR_age_mon <- linelist %>% 
  group_by(
    eth_race,
    month = floor_date(date_report, "month")) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes", na.rm=T),
    CFR = deaths/cases,
    med_age = median(age, na.rm=T),
    med_dur = median(days_hosp, na.rm=T)
  ) %>% 
  drop_na(month)
``` 

]

.pull-right [ 
```{r, echo=T, eval=F}
library(gganimate)

month_plot <- ggplot(
  data = race_CFR_age_mon,
  mapping = aes(
    x = cases,
    y = deaths,
    size = cases,
    color = eth_race))+
  geom_point(alpha = 0.5)+
  labs(title = "Month: {month}")+
  gganimate::transition_time(month)+
  ease_aes('linear')
  
  
  

zip_plot <- ggplot(
  data = zip,
  mapping = aes(
    x = cases,
    y = deaths,
    size = cases,
    color = zip))+
  geom_point(alpha = 0.5)+
  labs(title = "Month: {month}")+
  theme(legend.position = "none")
  #gganimate::transition_time(month)+
  #ease_aes('linear')

```

]











---

# Advanced: the **scales** package

This package offers many ways to ease the visualization of numbers in plots  

See [https://scales.r-lib.org/](https://scales.r-lib.org/).  



---
# **scales** - simplify date axis  

class: small-table

.pull-left[

We make a new dataset to demonstrate use of `scales::label_date_short()`.  

```{r, echo=T, eval=T}
# no lag accounted for, for simplicity
CFR_data <- linelist %>% 
  group_by(month = floor_date(date_report, "month")) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes", na.rm=T),
    CFR = deaths / cases)

```


] 

.pull-right[

These are the first 6 rows:  

```{r, echo=F, eval=T}
CFR_data %>% 
  head(6) %>%
  knitr::kable()
```
]


---
# **scales** - simplify date axis  

.pull-left[

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
    y = CFR))+
  geom_line(size = 2)+
  scale_x_date(date_breaks = "3 months")
```

`scales::label_date_short()` will instantly make nice date labels, and reduces the number of times the "year" appears.



] 

.pull-right[

```{r, eval = T, echo=F}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
    y = CFR))+
  geom_line(size = 2)+
  scale_x_date(date_breaks = "3 months")
```

The default date labels... not great.  

]



---
# **scales** - date axis  

.pull-left[

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = date_report,
    y = CFR))+
  geom_line(size = 2)+
  scale_x_date(
    date_breaks = "3 months",
*   date_labels = "%d %b \n %Y")
```

You can manually adjust the date labels this way, as we know, but the year appears multiple times.  

Note use of `date_labels=` here, not `labels=`.  

] 

.pull-right[

```{r, eval = T, echo=F}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
    y = CFR))+
  geom_line(size = 2)+
  scale_x_date(
    date_breaks = "3 months",
    date_labels = "%d %b \n %Y")
```
Better... but the years are redundant.  

]



---
# **scales** - date axis  

.pull-left[


```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = date_report,
    y = CFR))+
  geom_line(size = 2)+
  scale_x_date(
    date_breaks = "3 months",
*   labels = scales::label_date_short())
```

`scales::label_date_short()` instantly makes nice date labels, and reduces the number of times the "year" appears.

Note use of `labels=` here, not `date_labels=`.

] 

.pull-right[
```{r, eval = T, echo=F}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
    y = CFR))+
  geom_line(size = 2)+
  scale_x_date(
    date_breaks = "3 months",
    labels = scales::label_date_short())
```
]




---
# **scales** - percents axis  

.pull-left[


```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
*   y = scales::percent(CFR),
    size = cases))+
geom_point(alpha = 0.5)+
geom_label_repel(
 aes(label = str_glue("{eth_race}\n{scales::comma(cases)} cases")),
 size = 4)
```

`scales::percent()` converts proportions into percents maintaining a numeric axis. If you otherwise add "%" the class will convert to character.

] 

.pull-right[
```{r, eval = T, echo=F}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = scales::percent(CFR),
    size = cases))+
geom_point(alpha = 0.5)+
labs(y = "CFR")+  
geom_label_repel(
 aes(label = str_glue("{eth_race}\n{scales::comma(cases)} cases")),
 size = 4)
```
]




---
# Combining plots  

DRAFT - The **cowplot** package




---
# Final slide


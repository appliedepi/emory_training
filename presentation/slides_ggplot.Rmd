---
title: "Emory COVID-19 Response Collaborative"
subtitle: "Data visualization with ggplot2: an overview and demonstration"
author: '[EpiRhandbook Team](https:://epirhandbook.com) <br><br> `r icons::icon_style(icons::fontawesome("twitter"), fill = "white")` [epiRhandbook](https://twitter.com/epiRhandbook) <br> `r icons::icon_style(icons::fontawesome("paper-plane"), fill = "white")` [epirhandbook@gmail.com](mailto:epirhandbook@gmail.com)'
date: "August 2021"
output:
  xaringan::moon_reader:
    self_contained: FALSE
    seal: TRUE
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
---

```{r, echo=F}
# You need to run this line once, for the slides to render 
# remotes::install_github("mitchelloharawild/icons")
# icons::download_fontawesome()

# Use this command to run preview-mode in RStudio. Save Rmd to update slide preview
# xaringan::inf_mr()
```


```{css, echo = F}
/* THIS IS A CSS CHUNK - THIS IS A COMMENT */

/* Size of font in code echo. E.g. 10px or 50% */
.remark-code {
  font-size: 70%;
}


/* Size of font in text */

.medium-text {
  font-size: 75%;     
}

/* Size of font in tables */

.small-table table {
  font-size: 6px;     
}

.medium-table table {
  font-size: 8px;     
}

.medium-large-table table {
  font-size: 10px;     
}

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.retina = 3  ## retina more effective than w/h (according to twitter)
                      # fig.width = 16, 
                      # fig.height = 10
                      )

## I dont know why this is included in the example xaringan slide 
## but is something to do with background images
options(htmltools.dir.version = FALSE)
```


```{r}
## install and load necessary packages 
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  skimr,      # review data
  janitor,    # data cleaning and tables
  epikit,     # age categories
  lubridate,  # working with dates
  incidence2, # epidemic curves
  ggrepel,    # smart labels
  ggExtra,    # extras
  esquisse,   # point-and-click for simple ggplots
  apyramid,   # age pyramids
  scales,     # formatting of scales
  plotly,     # interactive plots
  cowplot,    # combine plots
  tidyverse,  # data management and visualization
  xaringanthemer,  # for styling presentation 
  sf,         # spatial data
  ggspatial  # basemaps and scalebars 
)


## load packages from github
pacman::p_load_gh(
     "R4IDSR/epichecks"   # bivariate colour maps 
)

```


```{r xaringan-themer, include = FALSE}

## define presentation colours (theme) using {xaringanthemer} package 
## https://pkg.garrickadenbuie.com/xaringanthemer/articles/xaringanthemer.html

## epirhandbook logo colours: 
  ## blue: "#00538c"
  ## green: "#007732"
  ## lighter green: "#48a878"

## see ?style_mono_accent for all the things can customise
style_mono_accent(
  base_color = "#00538c", 
  link_color = "#48a878", 
  ## add logo to the title page (bit bigger)
  title_slide_background_image = "https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/epiRhandbook_HexSticker_500x500.png", 
  title_slide_background_position = "100% 100%", 
  title_slide_background_size = "25%", 
  ## add logo to all following slides
  background_image = "https://github.com/appliedepi/emory_training/raw/master/presentation/images/AppliedEpi_Hex.png", 
  background_size = "10%",
  background_position = "100% 0%"
)

```


# We are Applied Epi  

![](https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/Epi%20R%20Handbook%20Banner%20Beige%201500x500.png)

* We are a grassroots collaborative of applied epidemiologists  
* Our (free) **Epi R Handbook** has been used by 60,000 people worldwide
* Now we offer customized training to health departments and NGOs  


.footnote[Bookmark [www.epiRhandbook.com](www.epirhandbook.com)!]  


???
- What makes us different is that we focus on the challenges of applied epi, not academic epi. We emphasize the skills used every day by ground-level epidemiologists. 


---
# Introducing ourselves  

* **Neale Batra**  
 - Founder of the Epi R Handbook.  
 - Previously @Philly, @SantaClaraCounty, and @USAID/PEPFAR. Internationally with @MSF and @WHO.  
* **Alex Spina**  
 - Alum of EPIET (European EIS). Med student and epi consultant for @MSF and @WHO.  
* **Mathilde Mousset**  
 - R programmer / Data manager at Epicentre (@MSF). PhD in evolutionary ecology.  
* **Henry Laurenson-Schafer**  
 - Epi/data scientist with WHO Geneva on COVID response. PhD in molecular biology/bioinformatics.  
* **Wen Lin** 
 - Epi @SantaClaraCounty, **Resident SAS expert**. 

???
We have Wen available for answering any questions on translating SAS to R 



---
# Today's demonstration  

Today is primarily *explanation* and *demonstration*, following from the previous [demonstration on data management and workflow](https://appliedepi.github.io/emory_training/presentation/slides_workflow.html).  

We assume you have reviewed the Handbook pages on [R Basics](https://epirhandbook.com/r-basics.html) and [ggplot basics](https://epirhandbook.com/ggplot-basics.html).  

![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/EDGE.png?raw=true)  




???
- Today's session is primarily a *demonstration* with question & answer session.  
- We assume that you have read at least some of the relevant pages in the Epi R Handbook prior to this session.  
- We also offer training in which we guide you through case studies with hands-on coaching. 


---
# Objectives  

Our objectives today are to:  

1) De-mystify `ggplot()` syntax so you can apply it to your own tasks  
2) Demonstrate core `geom_()` commands  
3) Introduce helpful "wrapper" packages like **incidence2** and **apyramid**  
4) Touch upon advanced tips with packages **ggExtra**, **ggrepel**, **gghighlight**, **scales**, **plotly**, and **esquisse**  


.footnote[The [Epi R Handbook](https://epirhandbook.com/index.html) contains many more examples.]  



???
- 1 - core syntax and 2 - exposure
- Ready yourself because today will be a whirlwind.
- There will be a LOT of content and we will move quickly.
- Type questions in the chat, or hold them to the end.  
- We will do understanding checks throughout  



---
# Resources for you  

Today's work is within an R project, which can be [downloaded as a zipped file](https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/appliedepi/emory_training/tree/master/case_study).  

Today's code is available to you in `ggplot_demo.Rmd` (also online [here](https://github.com/appliedepi/emory_training/blob/master/case_study/ggplot_demo.Rmd)).  

R project file (`case_study.Rproj`)  
  * `data/` folder  
    * `covid_example_data/` folder 
        * `linelist_cleaned.rds` 
        * `covid_example_data.xlsx`  
        * `covid_shapefile/` folder  
          - `FultonCountryZipCode.shp`...
    * `map_tiles/` folder 
        * base map images for Fulton County...
  * `ggplot_demo.Rmd` (R markdown script)  


???
- Do NOT download and try it now. Too distracting.  
- Today will move fast, but just like last time the REAL opportunity for you is to review at your own pace.  
- We've spent a lot of time developing materials for you.  
- SHOW SCRIPT AND OUTPUT IN FOLDER  



---
# Load packages and import data  

Load packages (**ggplot2** is within [**tidyverse**](https://www.tidyverse.org/)) and import the cleaned (fake) dataset from [last session](https://github.com/appliedepi/emory_training/blob/master/case_study/weekly_report.Rmd).  

```{r, eval=F, echo=T}
## install and load necessary packages 
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  skimr,      # review data
  DT,         # visualize data frame
  janitor,    # data cleaning and tables
  epikit,     # age categories
  lubridate,  # working with dates
  incidence2, # epidemic curves
  ggrepel,    # smart labels
  ggExtra,    # extras
  esquisse,   # point-and-click for simple ggplots
  apyramid,   # age pyramids
  scales,     # formatting of scales
  plotly,     # interactive plots
  cowplot,    # combine plots
* tidyverse   # ggplot2 & data management
)
```

```{r echo=FALSE, eval=TRUE}
# This actually runs but is not displayed
linelist <- rio::import(here::here("case_study", "data", "covid_example_data", "linelist_cleaned.rds"))
```

```{r echo=TRUE, eval=FALSE}
linelist <- import(here::here("data", "covid_example_data", "linelist_cleaned.rds"))
```


???
One tip is to load tidyverse last to avoid masking of package names  
The `import()` function can import almost any kind of file. An `.rds` file retains column classes from an R data frame.






---

class: medium-large-table

# Review data  

Below are the first 25 rows of the `linelist` data frame:  

```{r}
head(linelist, 25) %>% 
  DT::datatable(
    options = list(
      scrollY = 300,
      scrollX = 600,
      pageLength = 25,
      fontSize = '25%',
      dom = "ti",
      ordering = FALSE,
      rownames = FALSE,
      options = list(pageLength = 5, scrollX=T),
      class = 'white-space: nowrap' 
    )
  )

  #knitr::kable(format = 'html')
```

.footnote[Tip: Use `skim()` from **skimr** package to review all columns with summary statistics]  





---
# Visualization options in R  

Today we focus on **ggplot2** because it:  

* is good for fast data exploration of multi-dimensional data  
* produces very **high quality** final outputs  
* has well-structured grammar => **high consistency**  
* is accompanied by many packages that expand functionality  

See the [R graph gallery](https://www.r-graph-gallery.com/ggplot2-package.html) for inspiration.  

.footnote[Other plotting options include [**base** R](https://towardsdatascience.com/base-plotting-in-r-eb365da06b22), [**lattice**](https://www.statmethods.net/advgraphs/trellis.html), and [**plotly**](https://plotly.com/r/).]  





---
# gg-what??  

--

- The **ggplot2** *package* is the most popular data visualization tool in R  

--

- Its `ggplot()` *function* is at the core of the package  

--

- This whole approach is colloquially known as “ggplotting”  

--

- Resulting figures are sometimes affectionately called “ggplots”  

--

**ggplot2** benefits from a wide variety of supplementary R packages that extends its functionalities, such as **gganimate**, **ggthemr**, **ggdendro**, **gghighlight**, **ggforce**...  

.footnote[
*Bonus question:* What does the "gg” in these names represent?
]

???
- "gg" represents the “grammar of graphics” used to construct the figures 





---
# Syntax overview  

Build a plot object by “adding” commands on top of one another that specify plot layers and design elements  


--

The order of layers will usually look like this:

1) **"Open" the plot** with the `ggplot()` command and specify the dataset  

--

2) **"Map" data columns** to "aesthetic" features of the plot such as axes, color, size, shape, fill, transparency  

--

3) **Add (`+`) “geom” layers** that visualize data geometrically as shapes  

--

4) **Modify "scales"**, such as a color scale or y-axis breaks  

--

5) **Add "theme" plot design elements** such as axis labels, title, caption, fonts, text sizes, background themes, or axes rotation  

--

These layers are "added" sequentially with `+` symbols.  
**ggplot2** commands can be quite long!  


???
Remember that although the commands may be long, it is infinitely easier to edit and recycle than in Excel  







---
# Open the plot  

.pull-left[

`ggplot()` creates an empty canvas. Assign the data frame to use.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)                   
```

Alternatively, use the `%>%` pipe operator to "pipe" a data frame *into* `ggplot()`  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
linelist %>%
  ggplot()
```

]

.pull-right[

```{r , echo = FALSE, eval = TRUE}
ggplot(data = linelist)
```
] 

???
This is only a blank canvas, we have not defined what should be in the x and y axes. 
If several data frames are needed, they can be added in their own geoms.
Piping is useful to make one-time changes to a dataset prior to plotting.  



---
# Mappings with `aes()`  

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
* mapping = aes(
*  x = age,
*  y = days_hosp))
```

"Aesthetics" are features *whose display could vary for each data point* (position, color, shape...)  

`mapping = aes()` assigns plot "aesthetics" to columns in the data. Inputs must be placed within `aes()`.  

Two basic aesthetic mappings are axes, via `x=` and `y=`.  


]

.pull-right[

```{r , echo = FALSE, eval = TRUE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp))+
theme_grey(base_size = 16)
```
] 



---
# Add geometry  

.pull-left[

```{r eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) +
*geom_point()
```

Data are visualized using "geom" commands, such as `geom_point()`.  

These commands are "added" with a `+` to the `ggplot()` command.  

]


.pull-right[

```{r eval=T, echo=F, message=F, warning=F}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp)) +
geom_point() + 
theme_grey(base_size = 16)
```

]




---
# Geometries  

.pull-left[

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`
Points          |`geom_point()`  


.footnote[Full list [here](https://ggplot2.tidyverse.org/reference/)]  

]


.pull-right[

```{r, message=F, warning=F}

# Histogram
histogram <- ggplot(
    data = linelist,
    mapping = aes(
      x = date_onset))+
  geom_histogram(fill = "darkorange")+
  labs(title = "geom_histogram()")+
  theme_minimal(base_size = 16)
  

points <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_hosp)
    )+
  geom_point()+
  labs(title = "geom_point()")+
  theme_minimal(base_size = 16)


cowplot::plot_grid(histogram, points,
                          nrow = 2, rel_widths = c(2,2))

#cowplot::plot_grid(top, lines, ncol = 1)

```

]






---
# Geometries  

.pull-left[

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`  
Points          |`geom_point()`  
Lines           |`geom_line()`  
Bar plots       |`geom_bar()` or `geom_col()`  


.footnote[Full list [here](https://ggplot2.tidyverse.org/reference/)]

]


.pull-right[

```{r, message=F, warning=F}

lines <- linelist %>% 
  group_by(eth_race,
           week_report = lubridate::floor_date(date_report, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_report) %>% 
  ggplot(
    mapping = aes(
      x = week_report,       
      y = n_cases,
      color = eth_race),
    size = 4
    )+
  geom_line()+
  labs(title = "geom_line()")+
  theme_minimal(base_size = 16)

bars <- linelist %>% 
  ggplot(mapping = aes(
      y = died,
      fill = died))+
  geom_bar()+
  labs(title = "geom_bar()")+
  theme_minimal(base_size = 16)+
  theme(legend.position = "none")

cowplot::plot_grid(lines, bars,
                   nrow = 2, rel_widths = c(2,2))


```

]





---
# Geometries  

.pull-left[

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`
Points          |`geom_point()`  
Lines           |`geom_line()`  
Bar plots       |`geom_bar()` or `geom_col()`  
Boxplots        |`geom_boxplot()`  
Violin plots    |`geom_violin()`  


.footnote[Full list [here](https://ggplot2.tidyverse.org/reference/)]

]


.pull-right[

```{r, message=F, warning=F}

boxplots <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = age)
    )+
  geom_boxplot()+
  labs(title = "geom_boxplot()")+
  theme_minimal(base_size = 16)



violins <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = days_hosp,
      fill = died)
    )+
  geom_violin()+
  labs(title = "geom_violin()")+
  theme_minimal(base_size = 16)


cowplot::plot_grid(boxplots, violins,
                          #smooth, density,
                          
                          nrow = 2, rel_widths = c(2,2))


```

]








---
# Adding geoms  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp)) +
*geom_point()
```

With axes now mapped, `geom_point()` displays the data as points.  

]

.pull-right[


```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp)) +
geom_point() +
theme_grey(base_size = 16)
```

] 











---
# Adding geoms  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
   x = age,
   y = days_hosp)) +
geom_point() +
*geom_smooth()
```

We can add additional geoms to the current plot with `+`.  

*Geoms appear in the order they are written*: the smoothed line appears over the points.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) +
geom_point() +
geom_smooth() +
theme_grey(base_size = 16)
```
] 

.footnote[geom_smooth() gives smoothed conditional means, helping to show trends in presence of "over-plotting" (see [documentation](https://ggplot2.tidyverse.org/reference/geom_smooth.html))]


???
- Explain why you might use one or the other





---
# A quick note on indentations  

Indentations, spaces, and newlines do not impact code execution, and can be varied to improve readability.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist, mapping = aes(x = age, y = days_hosp))+geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(x = age, y = days_hosp)) +
geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,        # use case linelist
  mapping = aes(          # make aesthetic mappings for all geoms
    x = age,              # assign x-axis to age column
    y = days_hosp)) +     # assign y-axis to duration of hospitalization
geom_point()              # display data as points
```



???
- Explain why you might use one or the other 
long style can enable informative comments/annotations
- short style very dense (harder to read for some). Shorter scripts, but so what? The number of lines of your code is not an informative metric.
- very long lines => needs to scroll horizontally for people with smaller monitors (not nice)
- long-ish style makes it easier to see which argument belongs to each function
- spaces around "=" or "+" => make it easier to parse to many people
- other?













---

class: large-table

# Other aesthetics  

Aside from axes, other common "aesthetics" include: 

Argument        |Controls                
----------------|-----------------------
`shape`      |Display of point as dot, star, triangle, square...
`fill`       |The *interior* color (e.g of bar or boxplot)  
`color`      |The *exterior* or bar, boxplot - OR point color  
`size`       |Line thickness, point size...
`alpha`      |Transparency: 0 (invisible) to 1 (opaque) 
`width`      |Width of "bar plot" bars
`linetype`   |Either solid, dashed, dotted, etc.  
`binwidth`   |Width of histogram bins  
  


???

Note that “aesthetic” in ggplot has a specific meaning that you might associate with the word “aesthetics” in common English. In ggplot those details are called “themes” and are adjusted within a theme() command

Each geom accepts certain aesthetics, like `binwidth=` for `geom_histogram()`






---

class: medium-text

# Aesthetics assignments  


.pull-left[

Aesthetics can be assigned to either:  

* **Static values**: `color = "purple"`  
  - Assigned *outside* `aes()`  
  - Same display for all data  

* **A data column**: `aes(color = died)`  
  - Assigned *inside* `aes()`
  - Displays data as "groups"  
  

]


.pull-right[

Some examples:  

```{r, message=F, warning=F}

color_purple <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(color = "purple")+
  theme_minimal(base_size = 16)+
  labs(title = "Using color = 'purple'")

color_died <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(aes(color = died))+
  theme_minimal(base_size = 16)+
  labs(title = "Using aes(color = died)")

cowplot::plot_grid(color_purple, color_died,
                  nrow = 2, rel_widths = c(2,2))


```

]




---

class: medium-text

# Aesthetics assignments  


.pull-left[

Aesthetics can be assigned to either:  

* **Static values**: `fill = "purple"`  
  - Assigned *outside* `aes()`  
  - Same display for all data  
  
* **A data column**: `aes(fill = died)`  
  - Assigned *inside* `aes()`
  - Displays data as "groups"  
  

]


.pull-right[

More examples:  

```{r, message=F, warning=F}

fill_purple <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(fill = "purple")+
  theme_minimal(base_size = 16)+
  labs(title = "Using fill = 'purple'")


fill_died <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(aes(fill = died))+
    theme_minimal(base_size = 16)+
  labs(title = "Using aes(fill = died)")

cowplot::plot_grid(
                  fill_purple, fill_died,
                   
                   nrow = 2, rel_widths = c(2,2))


```

]





```{r, message=F, warning=F, eval=F}

shape_3 <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(shape = 3)+
  theme_minimal()+
  labs(title = "shape = 3")

shape_died <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(aes(shape = died))+
  theme_minimal()+
  labs(title = "aes(shape = died)")

###

fill_purple <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(fill = "purple")+
  theme_minimal()+
  labs(title = "fill = 'purple'")


fill_died <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(aes(fill = died))+
    theme_minimal()+
  labs(title = "aes(fill = died)")

###

col <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(fill = "lightgreen", color = "purple")+
  theme_minimal()+
  labs(title = "fill = 'lightgreen', color = 'purple'")


col_died <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(aes(fill = died), color = "black")+
  theme_minimal()+
  labs(title = "aes(fill = died), color = 'black'")


cowplot::plot_grid(shape_3, shape_died,
                  fill_purple, fill_died,
                   col, col_died,
                   ncol = 2, rel_widths = c(2,2))


```









---
# Static aesthetics  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) + 
*geom_point(color = "seagreen")
```


An aesthetic is *static* if it applies the same display to all data points in the geom or plot. Static aesthetics are defined *outside* `aes()` to a *number or character value*.  

Other examples:  
`size = 3`  
`alpha = 0.5`  
`width = 1.2`  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
     x = age,
     y = days_hosp)) +
geom_point(color = "seagreen") +
theme_grey(base_size = 16)
```
] 






---
# Dynamic aesthetics   

.pull-left[

```{r, echo = TRUE, eval = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
*   color = died)) +
geom_point()
```


*Dynamic* aesthetics are mapped to a column name, and defined *inside* `aes()`. This creates "groups" in the plot and generates a legend. The display varies for each data point.  

Above, `color=` is mapped to column `died`, and is inherited by `geom_point()`.   

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died)) +   
geom_point()+
theme_grey(base_size = 16)
```
]

???




---
# Static and dynamic  

.pull-left[


```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
*   color = died)) +  
geom_point(
* size = 7, 
* alpha = 0.7) 
```

Above, `size = 7` and `alpha = 0.7` are static aesthetics defined outside any `aes()` and apply to `geom_point()`.  

`color=` is within an `aes()`, and maps to values in column `died`.  


]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died))+      # color varies by outcome
geom_point(size = 7,     # all points 7x size
           alpha = 0.7)+ # transparency 
theme_grey(base_size = 16)     
```
]

.footnote[Read more about ggplot aesthetics [here](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html)]  


???
As there is only one geom, all aesthetics can be written in `ggplot()`, or in `geom_point()`




---
# Aesthetic mapping placement  

1) Dynamic mappings in the initial `ggplot()` call will apply to subsequent geoms, *unless otherwise indicated*  
2) Static aesthetics (e.g. `color = "blue"`) are not inherited by subsequent geoms  
3) Mappings written within one geom apply only to that geom  

.pull-left[
```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(                
  data = linelist,      
  mapping = aes(        
    x = age,
    y = days_hosp)) +
# points colored by outcome
geom_point(
  mapping = aes(color = died),
  size = 1) +
# smoothed means by outcome
geom_smooth(
  mapping = aes(color = died),
  size = 3) +
# smoothed mean of entire dataset
geom_smooth(color = "black")
```

]

.pull-right[

```{r, echo = F, eval = T, tidy = FALSE}
ggplot(                
  data = linelist,      
  mapping = aes(        
    x = age,
    y = days_hosp)) +
# points colored by outcome
  geom_point(
  mapping = aes(color = died),
  size = 1) +
# smoothed means by outcome
geom_smooth(
  mapping = aes(color = died),
  size = 3) +
# smoothed mean of entire dataset
geom_smooth(color = "black") +
theme_minimal(base_size = 16)
```
]


???
- Three rules to remember as you decide where to place aesthetic mappings
- This is rather complex example, but serves to demonstrate the above guidelines.  



---
# A common error  

.pull-left[

If your data are "grouped", yet you plot indiscriminately without the grouping assigned to a dynamic aesthetic, you get multiple y values per x value.  

Below, `linelist` is aggregated into counts per unique week-outcome.  

```{r, eval=F, echo = T, warning=F, message=F}
outcome_week_data <- linelist %>% 
* count(died,
*       week_onset = floor_date(
*         x = date_onset,
*         unit = "week")) %>% 
  select(week_onset, everything()) %>% 
  arrange(week_onset) %>% 
  drop_na(week_onset)
```
]


.pull-right[
First few rows:  

```{r, eval=T, echo = F, warning=F, message=F}
outcome_week_data <- linelist %>% 
  count(
    died,
    week_onset = lubridate::floor_date(
      x = date_onset,
      unit = "week")) %>% 

  select(week_onset, everything()) %>% 
  arrange(week_onset) %>% 
  drop_na(week_onset)

outcome_week_data %>%
  head(8) %>% 
  knitr::kable()
```

]



---
# A common error  

.pull-left[

```{r, echo=T, eval=F}
ggplot(
* data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n)) +
geom_line()
```

Above, the column `died` is not provided to any grouping aesthetic.  

`ggplot()` does not know how to display the multiple values for each week.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n)) +
geom_line()+
theme_grey(base_size = 16)

```

]



---

# A common error - resolved  

.pull-left[

```{r, echo=T, eval=F}
ggplot(
  data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n,
*   color = died))+
geom_line()
```

Use aesthetic mappings like `fill=` or `color=` to correctly visualize the "groups".  

Above, `color=` is mapped to the `died` column.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = outcome_week_data,
  mapping = aes(
    x = week_onset,       
    y = n,
    color = died)) +
geom_line() +
theme_grey(base_size = 16)


```
]



---
# Facets  



.pull-left[

```{r , echo = TRUE, eval = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(~eth_race)
```

Another way of *displaying groups* is via faceting. 

`facet_wrap()` produces one facet per unique value.  

Place a "~" before the column name.  


] 



.pull-right[

```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
facet_wrap(~ eth_race)+
theme_grey(base_size = 16)
```

]

???
Also called "small multiples"  


---

# Facets  

.pull-left[

```{r , echo = TRUE, eval = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(~eth_race,
            scales = "free_y")
```

"Free" auto-scaled axes with `scales=`. Options:  
- "free_y"  
- "free_x"   
- "free" (both x and y)  

] 

.footnote[
Alert your audience if you use free axes! 
Also, try `ncol=` and `nrow=`  

]


.pull-right[
```{r }
ggplot(data = linelist,
       mapping = aes(x = date_onset)) +
geom_histogram() +
facet_wrap(~eth_race,
           scales = "free_y") +
labs(caption = "Note the free y-axis")+
theme_grey(base_size = 16)
```

]




---
# Facets - by two variables


.pull-left[

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_wrap(eth_race ~ gender) 
```


The "~" signifies "by". You can place columns on either side.  
  
With `facet_wrap()`, levels are combined into facet titles, appearing alphabetically/by factor level.  

] 


.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
facet_wrap(eth_race ~ gender) + 
theme_grey(base_size = 16)
```

]




---
# Facets - grid layout


.pull-left[

Use `facet_grid()`. Labels appear on top and side.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*facet_grid(eth_race ~ gender) 
```

] 


.pull-right[

```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
facet_grid(eth_race ~ gender) + 
theme_grey(base_size = 16)
```

]


---
# Facets - drop levels


.pull-left[

Use `filter()` or `drop_na()` in advance, to remove undesired levels.  

```{r , echo = TRUE, eval = FALSE}
linelist %>% 
*  drop_na(gender, eth_race) %>% 
*  filter(gender != "Unknown") %>% 
  
  # begin plot
  ggplot(
    mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_grid(eth_race ~ gender) 
```

] 


.pull-right[

```{r }
linelist %>% 
  drop_na(gender, eth_race) %>% 
  filter(gender != "Unknown") %>% 
  
  ggplot(
    mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_grid(eth_race ~ gender) +
  theme_grey(base_size = 16)
```

]

.footnote[Above, we pipe the adjusted data frame into `ggplot()`, for ease]  



---
# Facets + `gghighlight()`

.pull-left[

Add `gghighlight()` from **gghighlight** to show a full "shadow" behind each facet. For color add the `aes(fill=)`.  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = date_onset,
*   fill = eth_race)) +
geom_histogram() +
facet_wrap(~ eth_race) +
*gghighlight::gghighlight()
```

] 


.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(
    x = date_onset,
    fill = eth_race)) +
geom_histogram() +
facet_wrap(~ eth_race) +
gghighlight::gghighlight() +
theme_minimal(base_size = 14)
```

]





---
# gghighlight

.pull-left[

Add `gghighlight()` to other plots, and specify specific values (or criteria) to highlight 

```{r, echo=T, eval=F}
linelist %>% 
  # get daily counts by age group
  group_by(age_group, date_report) %>%
  count() %>% 
  
  # plot
  ggplot(
    mapping = aes(
      x = date_report,
      y = n,
      color = age_group)) +
  geom_line() +
* gghighlight::gghighlight(
    age_group %in% c("40-49", "60-69)"))+
  theme(legend.position = "none")
  
```




] 


.pull-right[
```{r echo=F, eval=T}
linelist %>% 
  # get daily counts by zip code
  group_by(age_group, date_report) %>%
  count() %>% 
  
  # plot
  ggplot(
    mapping = aes(
      x = date_report,
      y = n,
      color = age_group)) +
  geom_line()+
  gghighlight::gghighlight(age_group %in% c("40-49", "60-69")) +
  theme(legend.position = "none")
```

]




---
# Scales - overview  

Scale commands replace defaults of *how* the aesthetic mappings manifest, such as:  
* *Which* colors or shapes to display  
* The min/max of point sizes  
* The min/max and frequency of axes breaks  

As a generic formula, these commands are written as: **`scale_AESTHETIC_METHOD()`**.  

1) `scale_` : this prefix never changes  
2) AESTHETIC: `_fill_` , `_color_` , `_x_` , `_y_` , etc.  
3) METHOD: `_continuous()`, `_discrete()`, `_manual()`, `_date()`, etc.





---
# Scales examples  

Some examples of scale commands:  

You want to adjust  |Scale command
--------------------|-------------------
continuous y-axis   |`scale_y_continuous()`
date x-axis         |`scale_x_date()`  
categorical x-axis  |`scale_x_discrete()`  
fill, continuous    |`scale_fill_continuous()`
fill, continuous    |`scale_fill_gradient()`  
color, manual assign|`scale_color_manual()`  




---
# Scales - default 

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar()
```


Above, the fill of a bar plot uses the **default colors and axis breaks**:  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar() +
theme_gray(base_size = 18)
```

]



---
# Scales - adjusted fill 

.pull-left[


```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar() +
*scale_fill_manual(        
*  values = c(
*   "Yes"     = "violetred", 
*   "No"      = "aquamarine",
*   "Unknown" = "grey"))


```

Within `scale_fill_manual()` we provide assignments within a vector `c()`.  


.footnote[Use *na.value = "grey"* for missing values]  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar() +
scale_fill_manual(        
  values = c(
    "Yes" = "violetred", 
    "No" = "aquamarine",
    "Unknown" = "grey")) +
theme_gray(base_size = 16)
```
]

???
Discuss the na.value= arguments in most scale commands, and the difference between having NA values in the data and having an explicit missing value such as "Unknown".


---
# Scales - adjusted y-axis 

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar() +
scale_fill_manual(        
  values = c(
    "Yes"     = "violetred", 
    "No"      = "aquamarine",
    "Unknown" = "grey")) +
*scale_y_continuous(
*  breaks = seq(from = 0,
*               to = 35000,
*               by = 5000))
```

In `scale_y_continuous()` we adjust the y-axis breaks using `seq()` to define a numeric sequence.   

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar() +
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey")) +
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000)) +
theme_gray(base_size = 18)
```

]





---
# Scales - Start axes at 0 

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar() +
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey")) +
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
* expand = c(0, 0)) +
*scale_x_discrete(
*  expand = c(0, 0))
```

In any `scale_x_` or `scale_y_` command, use `expand = c(0,0)` to remove excess space around the plot features.  

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race,
    fill = died)) +
geom_bar() +
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey")) +
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
  expand = c(0,0)) +
scale_x_discrete(
  expand = c(0,0)) +
theme_grey(base_size = 18)
```

]




---
# Scales - date axis labels

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram()
```

The default scale for date axes will vary by the range of your data.  

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram()+
theme_grey(base_size = 18)

```

]







---
# Scales - date label breaks

.pull-left[


```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
*scale_x_date(
*  date_breaks = "3 months")

```

Adjust axis labels with `scale_x_date()`.  

Use `date_breaks=` values like "1 week", "2 weeks", or "3 months". 


Note: these are the *axis* label breaks, not histogram bin breaks!  

.footnote[
Note: Default "weeks" start on Mondays. See [epiRhandbook epicurves](https://epirhandbook.com/epidemic-curves.html) page for alternatives.
]

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months") +
theme_grey(base_size = 18)

```

]

???
For tips on geom_histogram() bins, see Epi R Handbook epicurves page








---
# Scales - date axis labels

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
* date_labels = "%d %b\n%Y")

```

Specify date label format to `date_labels=` using ["strptime" syntax](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/strptime)  

`"%d %b %Y"` for DD MMM YYYY.  


See Epi R Handbook [Epicurves](https://epirhandbook.com/epidemic-curves.html) and [Strings](https://epirhandbook.com/characters-and-strings.html) pages for more tips

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
  date_labels = "%d %b\n%Y"
) +
theme_grey(base_size = 18)

```

]


???
/n is a newline






---
# Scales - date axis labels

.pull-left[

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
* labels = scales::label_date_short() )

```

Alternatively, simplify by assigning `labels=` to `label_date_short()` from [**the scales package**](https://scales.r-lib.org/)  

The year is not repeated on each label anymore.  

]

.pull-right[

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)) +
geom_histogram() +
scale_x_date(
  date_breaks = "3 months",
  labels = scales::label_date_short())+
theme_grey(base_size = 18)

```

]

.footnote[Note the use above of `labels=`, not `date_labels=`.]







---

class: medium-large-table  

# Scales - display percents  

.pull-left[

Easily display proportions as percents with `percent()` from **scales** within `scale_y_continuous()`.  

```{r, echo=F, eval=T}
# no lag accounted for, for simplicity
CFR_data <- linelist %>% 
  group_by(month = floor_date(date_report, "month")) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes", na.rm=T),
    CFR = deaths / cases)

```


First few rows of a CFR dataset:  

```{r, echo=F, eval=T}
CFR_data %>% 
  head(4) %>%
  knitr::kable()
```

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
*   y = CFR) +
geom_line(size = 2, color = "brown") +
*scale_y_continuous(labels = percent)
```

] 

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = CFR_data,
  mapping = aes(
    x = month,
    y = CFR)) +
geom_line(size = 2, color = "brown")+
scale_y_continuous(labels = percent) +
theme_grey(base_size = 18)

```
]


???
Remember to load the scales package




---
# Plot labels  

.pull-left[

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist) +
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3) +
*labs(
*  title = "Duration of admission",
*  subtitle = "Fulton County, GA",
*  x = "Age (years)",
*  y = "Duration (days)",
*  caption = "Fictional COVID-19 data",
*  color = "Deceased"
)
```


Use `labs()` as above. 

Note: to edit legend title, use the aesthetic that created the legend (e.g. `color=`).  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist)+
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3) +
labs(
  title = "Duration of admission",
  subtitle = "Fulton County, GA",
  x = "Age (years)",
  y = "Duration (days)",
  caption = "Fictional COVID-19 data",
  color = "Deceased"
) +
theme_grey(base_size = 18)
```
]



---
# Plot label tips  

See the [Epi R Handbook page](https://epirhandbook.com/characters-and-strings.html#dynamic-strings) on adjusting characters with the **stringr** package

**New lines**  

```{r, eval=F, echo=T}
"Top line\nNextline"                        # \n creates new line
str_wrap("This is a really long title", 30) # wrap at 30 characters
```


--


**Dynamic labels** - Embed code in `str_glue()` that updates with the data  

```{r, eval=T, echo=T}
str_glue("Data as of {Sys.Date()}")
```

```{r, eval=T, echo=T}
str_glue("{fmt_count(linelist, is.na(date_onset))} cases missing onset and not shown")
```



???
Explain that in str_glue, anything within curly brackets it will run as R code.  







---
# Themes  

.pull-left[

Themes are non-data design features (background, text size/color, etc).  

[These "complete themes"](https://ggplot2.tidyverse.org/reference/ggtheme.html) are easy to add.  

```{r, eval=F, echo=T}
# Try one of these...
theme_bw()+
theme_classic()+
theme_dark()+
theme_gray()+
theme_minimal()+
theme_light()+
theme_void()+
```

Try the argument `base_size = 16` to quickly increase text size.  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}

minimal <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_minimal()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_minimal(base_size = 18)



bw <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_bw()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_bw(base_size = 18)



grey <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_grey()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_grey(base_size = 18)


dark <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_dark()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_dark(base_size = 18)



void <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_void()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_void(base_size = 18)



light <- ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "theme_light()",
    x = "Age (years)",
    y = "Duration (days)")+
  theme_light(base_size = 18)


themes_plots <- cowplot::plot_grid(
  minimal, light,
  bw, grey,
  dark, void,
  nrow = 3, rel_widths = c(2,2))

themes_plots

```



]






---
# Themes  

.pull-left[

Make micro-adjustments with `theme()`. See the handbook for tips.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
    alpha = 0.3) +
geom_point() +
labs(
  title = "Duration of admission",
  x = "Age (years)",
  y = "Duration (days)",
  color = "Deceased")+
theme_minimal(base_size = 16) +
*theme(
* legend.position = "bottom",
* plot.title = element_text(
*   color = "red",
*   face = "bold"),
* axis.title.y = element_text(angle = 90))
```

]

.pull-right[

The syntax takes practice - see [this list](https://ggplot2.tidyverse.org/reference/theme.html) of feature-specific arguments.

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "Duration of admission",
    x = "Age (years)",
    y = "Duration (days)",
    color = "Deceased")+
  theme_minimal(base_size = 16)+
  theme(
    legend.position = "bottom",
    plot.title = element_text(color = "red",
                              size = 20,
                              face = "bold"),
    axis.title.y = element_text(angle = 0))
```
]

???
Talk about these theme() arguments and how they consist of two parts, just like `mapping = aes()`. 
Explain that nobody has these all memorized, but the common ones are easy to remember once you use them enough.  
Remember to add them AFTER any complete themes.





---
# Bar plots  

`geom_col()` and `geom_bar()` are used to make general bar plots (non-epicurves).

--

Use `geom_bar()` if bar height should reflect the **number of rows** in the data
(e.g. a case linelist).  

```{r, echo=T, eval=F}
ggplot(
  data = linelist,                  # begin with linelist
  mapping = aes(x = eth_race)) +    # No y= argument
*geom_bar()                           
```

--

Use `geom_col()` there is a numeric column containing the desired **bar height**
(e.g. aggregated count data).  

```{r, eval=F, echo=T}
ggplot(
  data = linelist_agg,                  # begin with aggregated count data   
  mapping = aes(x = eth_race, y = n)) + # bar height is value in column "n"                                     
*geom_col()   
```







---

class: medium-table

# Bar plot - count rows  

.pull-left[

With `geom_bar()`, the height reflects the number of rows per x-axis group. This works well for linelist data.  

```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(
  data = linelist,
  mapping = aes(
    x = eth_race)) +             
geom_bar() +
theme(axis.text.x= element_text(angle=30))  
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(x = eth_race)) +             
geom_bar()+                  
theme_grey(base_size = 16) +
theme(axis.text.x= element_text(angle = 30))
```
]

---

class: medium-table

# Bar plot - count grouped rows  

.pull-left[

To achieve "stacked" bars with `geom_bar()`, assign the grouping column to `fill=`, within `aes()`.  

```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(
  data = linelist,
  mapping = aes(
      x = eth_race,   
*     fill = died)) +             
geom_bar() + 
theme(axis.text.x= element_text(angle=30))
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(
  data = linelist,
  mapping = aes(
      x = eth_race,   
      fill = died)) +             
geom_bar()+     
theme_grey(base_size = 16)+
theme(axis.text.x= element_text(angle = 30))
```
]



---

class: medium-table

# Bar plot - aggregated counts  

.pull-left[

In contrast, `geom_col()` uses a column of counts, such as column `n` in this `linelist_eth` dataset:

```{r, eval=T, echo=F}
linelist_eth <- linelist %>% 
  count(eth_race)

linelist_eth %>% 
  head(6) %>% 
  knitr::kable()
```

Column `n` provides the bar height.    

```{r, echo=T, eval=F}
ggplot(linelist_eth) +             
*  geom_col(           
    mapping = aes(   
      x = eth_race,    
*     y = n))+
theme(axis.text.x= element_text(angle= 30))         
```


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist_eth) +             
 geom_col(           
    mapping = aes(   
      x = eth_race,    
      y = n))+
theme(axis.text.x= element_text(angle = 30))
  
```


]


---

class: medium-table

# Bar plot - stacked counts  

.pull-left[

To have "stacked" bars using `geom_col()`, each plotting group must have its own rows in the data. Use "long"-style data like below:  

```{r, echo = F, eval=T}
linelist_eth_died <- linelist %>% 
  count(eth_race, died)

linelist_eth_died %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist_eth_died) +               
geom_col(                 
  mapping = aes(
    x = eth_race,          
*   y = n,                
*   fill = died)) +
theme(axis.text.x= element_text(angle=30))
```

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died) + # begin with data aggregated by day/ethnicity              
  geom_col(                # column height by aggregated counts
    mapping = aes(
      x = eth_race,            # one bar per ethnicity. 
      y = n,               # bar height from column "n"
      fill = died)) +        # stacked bars by outcome
theme_grey(base_size = 16)+
theme(axis.text.x= element_text(angle = 30))
```

.footnote[See the pivoting page in the Epi R Handbook]

]



---

# Bar plot - a common error 

.pull-left[

If your data look like below (counts) and your plot looks like that (bars of same height), ensure you are using `geom_col()` and not `geom_bar()`!  

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  knitr::kable()
```

]

.pull-right[

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  ggplot()+
  geom_bar(
    mapping = aes(x = eth_race))+
  theme_grey(base_size = 16)
```

This plot shows that there is one row per ethnicity/race!  

]


---
# Bar plot - flip axes  

.pull-left[

```{r, echo=T, eval=F}
ggplot(linelist) +        
geom_bar(              
  mapping = aes(
    x = eth_race,            
    fill = died)) +
theme(legend.position = "top") +  
*coord_flip()           
```

It is simple to flip the axes on any ggplot by adding `coord_flip()`  

This is useful in bar plot to improve readability.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist) +             
  geom_bar(              
    mapping = aes(
      x = eth_race,          
      fill = died)) + 
coord_flip() + 
theme_grey(base_size = 16)+
theme(legend.position = "top")  

```
]





---
# Bar plot - adjust order    

.pull-left[



```{r, echo=T, eval=F}
ggplot(linelist) +        
geom_bar(                
  mapping = aes(
*   x = fct_infreq(eth_race),   
*   fill = fct_infreq(died))) + 
theme(legend.position = "top") +  
coord_flip()
```

Use the **forcats** package to convert to class *factor* and adjust "level" order.  

Above, `fct_infreq()` orders x-axis position and stacks (fill) by frequency.  

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist) +             
geom_bar(              
  mapping = aes(
    x = fct_infreq(eth_race),   
    fill = fct_infreq(died))) +  
coord_flip() + 
theme_grey(base_size = 16)+
theme(legend.position = "top") 
```
]



.footnote[See the Epi R Handbook page on [factors](https://epirhandbook.com/factors.html#within-a-plot).]  



???
You will need to clean up the axes and legend titles now.  


---
# Bar plot - reverse order  

.pull-left[


```{r, echo=T, eval=F}
ggplot(linelist)  +              
geom_bar(                
  mapping = aes(
*   x = fct_rev(fct_infreq(eth_race)),   
*   fill = fct_rev(fct_infreq(died)))) +      
theme(legend.position = "top") + 
coord_flip()              
```


To *reverse* order, use `fct_rev()`, which can be wrapped around other functions. 

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist) +             
geom_bar(              # column height by number of rows
  mapping = aes(
    x = fct_rev(fct_infreq(eth_race)),            
    fill = fct_rev(fct_infreq(died)))) +     
coord_flip() + 
theme_grey(base_size = 16) +
theme(legend.position = "top") 
```

]






---


# Bar plot - adjust width  

.pull-left[

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died)) +             
*geom_col(width = 0.5) +
theme(axis.text.x = element_text(angle = 30))

```

Adjust bar width with `width=`.  

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died,
       aes(x = eth_race, y = n, fill = died)) +             
  geom_col(width = 0.5) + 
  theme_grey(base_size = 16)+
theme(axis.text.x = element_text(angle = 30))
```

]

???
Be wary of adjusting width for date bars (e.g. month) - use `geom_histogram()` instead with bin breaks.  




---


# Bar plot - adjacent  

.pull-left[


```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = fct_infreq(died),
    label = n)) +             
*geom_col(position = "dodge")+
theme(axis.text.x = element_text(angle = 30))
```

To make the bars adjacent, specify `position = "dodge"` in `geom_col()`.  

.footnote[Adjust the order with via a **forcats** function.]

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = fct_infreq(died),
    label = n)) +             
  geom_col(position = "dodge") + 
  theme_grey(base_size = 16)+
theme(axis.text.x = element_text(angle = 30))
```

]



---


# Bar plot - display counts  

.pull-left[

To display text, use `geom_col()` with `geom_text()`. Assign `aes(label=)` to the height values.  

The `position=` arg in `geom_text()` can specify display at mid-bar.  

```{r, echo = T, eval=F}
ggplot(
  data = linelist_eth_died,
  mapping = aes(
    x = eth_race,
    y = n,
    fill = died,
*   label = n)) +             
geom_col() +
*geom_text(
* size = 3,
* position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle=30))
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died,
       aes(x = eth_race, y = n, fill = died, label = n)) +             
geom_col() +
geom_text(size = 3, position = position_stack(vjust = 0.5)) + 
theme_grey(base_size = 16) +
theme(axis.text.x = element_text(angle=30))
```

]










---

# Point-and-click ggplot2  

Now that you've learned the basic syntax... the [**esquisse**](https://cran.r-project.org/web/packages/esquisse/vignettes/get-started.html]) package allows point-and-click creation of (simple) ggplots! (esquisse means "sketch" in French)  

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/esquisse1.gif?raw=true")
```






---
# Make an epidemic curve  

Two approaches that we suggest:  

1) Use the **incidence2** package  
  * Fast, simple, and modifiable with ggplot additions  
  
2) Use ggplot's `geom_histogram()`  
  * Most customizeability  
  * Most complex code  

--

Today's demonstration will focus on **incidence2**.  

.footnote[See the Epi R handbook's [Epicurves page](https://epirhandbook.com/epidemic-curves.html) for detailed examples of both methods]  








---
# Epicurve - incidence object 

.pull-left[

**Create** an incidence object  

```{r, echo=T, eval=F}
weekly <- incidence(
  x = linelist,            
  date_index = date_onset, 
  interval = "week")          
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly)
```
]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
weekly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "week")       # bin interval   

plot(weekly)
```

]




---
# Epicurve - incidence object 

.pull-left[

Adjust the interval

```{r, echo=T, eval=F}
bimonthly <- incidence(
  x = linelist,            
  date_index = date_onset, 
* interval = "2 months")      
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(bimonthly)
```

Try "Sunday weeks" or "MMWR week" for Sunday weeks.  

]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
bimonthly <- incidence(
  x = linelist,            
  date_index = date_onset, 
  interval = "2 months")    

plot(bimonthly)
```

]




---
# Epicurve - groups 

.pull-left[

To show groups, specify them to `groups=` in the `incidence()` command:  

```{r, echo=T, eval=F}
weekly <- incidence(
  x = linelist,              
  date_index = date_onset,  
  interval = "weeks",       
* groups = eth_race)      
```

AND to `fill=` in the `plot()` command:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly,
* fill = eth_race)
```

If grouping by multiple columns, nest them in both places within `c()`:  

```{r, eval=F, echo=T}
groups = c(eth_race, gender)
```

]

.pull-right[



```{r, echo=F, eval=T}
weekly <- incidence(
  x = linelist,              
  date_index = date_onset,  
  interval = "weeks", 
  groups = eth_race) 

plot(weekly,
  fill = eth_race)+
  theme_minimal(base_size = 16)
```

]









---
# Epicurve - ggplot2 additions 


.pull-left[


```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly,
     fill = eth_race) +
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
*scale_y_continuous(
* expand = c(0,0),
* breaks = seq(0,2000,250)) + 
*theme_minimal(base_size = 16) + 
*theme(legend.position = "top") +
*labs(fill = "Race and\nEthnicity")
```

Add other **ggplot2** commands with `+`.  


]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly, fill = eth_race) +
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
scale_y_continuous(
 expand = c(0,0),
 breaks = seq(0,2000,250)) + 
theme_minimal(base_size = 16) + 
theme(legend.position = "top") +
labs(fill = "Race and\nEthnicity")
```

]




---
# Epicurve - date axis 

.pull-left[

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly,
  fill = eth_race,
*  date_format = "%a %d %b %Y\n (Week %W)", 
*  angle = 30)+                           
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
theme_minimal(base_size = 16) + 
theme(legend.position = "top") +
labs(fill = "Race and\nEthnicity")
```


Do not adjust **incidence2** epicurves with `scale_x_date()`.  

Instead, use custom **incidence2** arguments in `plot()`.  

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly,
  fill = eth_race,
  date_format = "%a %d %b %Y\n (Week %W)", 
  angle = 30)+                          
scale_y_continuous(
  expand = c(0,0),
  breaks = seq(0,2000,250)) + 
theme_minimal(base_size = 16) + 
theme(legend.position = "top") +
labs(fill = "Race and\nEthnicity")
```

]








---
# Epicurve - show cases 

.pull-left[

For small outbreaks, the style `show_cases = TRUE` may be helpful:  

```{r, eval=F, echo=T, warning=F, message=F}
small_outbreak <- linelist %>% 
  filter(
    zip == 30024,
    date_report >= as.Date("2020-12-01")) %>% 
  incidence(
    date_index = date_onset,               
    interval = "Sunday weeks",             
    groups = eth_race)
```

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(small_outbreak,
  fill = eth_race,
* show_cases = TRUE)+
theme(legend.position = "bottom")+
labs(
  title = "ZIP 30024 by race")
```

]

.pull-right[

```{r, echo=F, eval=T}
small_outbreak <- linelist %>% 
  filter(zip == 30024,
         date_report >= as.Date("2020-12-01")) %>% 
  incidence(
    # dataset is piped in from above
    date_index = date_onset,               
    interval = "Sunday weeks",             
    groups = eth_race)
```

```{r, echo=F, eval=T}
plot(small_outbreak,
  fill = eth_race,
 show_cases = TRUE)+
theme(legend.position = "bottom")+
labs(
  title = "ZIP 30024 by race") +
theme_minimal(base_size = 16)
```

]

???
Dataset is piped in from above






---
# Epicurve - color palettes  

.pull-left[

Use `scale_fill_viridis_d()` for palettes that are color-blind friendly:  

```{r, echo=T, eval=F}
plot(weekly, fill = eth_race)+
*scale_fill_viridis_d(
    option = "inferno",           
    name = "Race and\nEthnicity",  
    na.value = "grey")          
```

[Viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) (try with `option = "plasma"` or "inferno"), and [colorbrewer](https://www.r-graph-gallery.com/38-rcolorbrewers-palettes.html) palette functions can be added to any ggplot as well.  

.footnote[The `_d()` indicates a scale for discrete values]  

]

.pull-right[



```{r, echo=F, eval=T}
plot(weekly, fill = eth_race)+
   scale_fill_viridis_d(
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values
```


]



---

# Epicurve - aggregated counts  



.pull-left[

You can also use **incidence2** on data that are aggregated counts...  

```{r, eval=F, echo=T}
# For demo: aggregate linelist
linelist_day_counts <- linelist %>% 
*  count(
*    day = floor_date(date_report, "day"),
*    died) %>% 
  drop_na(day)
```

```{r, eval=T, echo=F}
# For demo: aggregate linelist
linelist_day_counts <- linelist %>% 
  count(
    day = floor_date(date_report, "day"),
    died) %>% 
  drop_na(day)
```

]

.pull-right[
A few rows of daily counts:  

```{r, eval=T, echo=F}
linelist_day_counts %>% 
  tail(10) %>% 
  knitr::kable(row.names = F)
```

]



---

# Epicurve - aggregated counts  

.pull-left[

```{r, eval=F, echo=T}
died_curve <- incidence(  
  linelist_day_counts,  
  date_index = day,   
* count = n,            
  interval = "week",    
  groups = died        
  )
```

```{r, eval=F, echo = T}
# plot stacked by outcome
plot(died_curve,    
     fill = died)   
```

]

.pull-right[

```{r, eval=T, echo=F}
died_curve <- incidence(   
  linelist_day_counts,   # dataset with counts aggregated by day
  date_index = day,      # column with dates
  count = n,             # column with counts
  interval = "week",     # aggregate daily counts up to weeks
  groups = died          # group by outcome
  )
```

```{r, eval=T, echo=F}
# plot the weekly incidence epi curve, with stacked bars by hospital
plot(died_curve,         # incidence object
     fill = died)        # color the bars by outcome
```

]


---
# Demographic pyramids  

We suggest two ways to make age pyramids:  

1) Use the **apyramid** package - simple, easy  

2) Use **ggplot2** - more customizeable, but opportunity for error  


Today we will demonstrate **apyramid**.  

.footnote[See the Epi R Handbook [page on demographic pyramids](https://epirhandbook.com/demographic-pyramids-and-likert-scales.html) and the [package vignette](https://cran.r-project.org/web/packages/apyramid/vignettes/intro.html) for more information.]  



---
# Demographic pyramids


.pull-left[

```{r, echo=F, eval=T}
linelist <- linelist %>% 
  mutate(
    gender = na_if(gender, "Unknown"), # convert to NA 
    gender = fct_drop(gender))         # drop unused factor levels
```

```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender")
```

The function `age_pyramid()` from **apyramid** offers an easy interface.  


.footnote[We have cleaned `gender` to only two values]  


]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender")
```

]



---
# Demographic pyramids

.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
* proportional = TRUE,
* show_midpoint = FALSE,
* pal = c("darkgreen", "brown"))
```


Further modifications:  

* Percents instead of raw counts on the x-axis  
* No mid-point designation  
* Specified colors  

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE,
  pal = c("darkgreen", "brown"))+
theme_minimal(base_size = 10)

```

]


---
# Demographic pyramids

.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
* stack_by = "hospitalized"
 proportional = TRUE,
 show_midpoint = FALSE,
 pal = c("darkgreen", "brown",
         "yellow", "orange"))
```

You can stack the bars by another variable with `stack_by=`  

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  stack_by = "hospitalized",
  proportional = TRUE,
  show_midpoint = FALSE,
  pal = c("darkgreen", "brown",
          "yellow", "orange"))+
theme_minimal(base_size = 10)

```

]


---
# Demographic pyramids


.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE) +
*theme_minimal(base_size = 10) +
*labs(
*  title = "Age and Gender",
*  subtitle = "Fulton County, GA",
*  x = "Percent of total",
*  y = "Age group",
*  fill = "Gender",
*  caption = "Caption here")
```

You can add further ggplot commands.  

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE) +
theme_minimal(base_size = 10) +
labs(
  title = "Age and Gender",
  subtitle = "Fulton County, GA",
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
  caption = "Caption here")
```

]


---
# Dynamic labels example

Let's use dynamic labels that will update with the data.  


```{r, eval=T, echo=F}
library(epikit)
```

**Simple caption**
```{r, eval=T, echo=T}
str_glue("n = {nrow(linelist)}")
```


--

**Complex caption**  


For complicated `str_glue()` scenarios, define the dynamic components outside the quotation marks.  

`fmt_count()` from **epikit** is useful to count and display rows.  

```{r, eval=T, echo=T}
str_glue("{missing} missing age or gender not shown.",
        missing = fmt_count(linelist, is.na(gender) | is.na(age_group))
        )
```



---
# Dynamic labels example


**Subtitle**  

Max/Min dates can be wrapped in `format()` from **base** to adjust the display. See the epiRhandbook section on [strptime syntax](https://epirhandbook.com/working-with-dates.html?q=strptime#format).  

```{r, eval=T, echo=T}
str_glue("Fulton County, reported {min_date} - {max_date}",
    min_date = format(min(linelist$date_report, na.rm=T), "%B %d %Y"),
    max_date = format(max(linelist$date_report, na.rm=T), "%B %d %Y")
    )
```







---
class: remark-code

# Dynamic captions

Now applying those dynamic captions:  

.pull-left[


```{r, echo=T, eval=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE) +
theme_minimal(base_size = 10) +
labs(
  title = "Age and Gender",
* subtitle = str_glue(
    "Fulton County, reported {min_date} - {max_date}",
  
    min_date = format(
      min(linelist$date_report, na.rm=T),
      "%B %d %Y"),
  
    max_date = format(
      max(linelist$date_report, na.rm=T),
      "%B %d %Y")
  ),
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
* caption = str_glue(
    "{missing} missing age or gender not shown.",
    missing = fmt_count(
      linelist,
      is.na(gender) | is.na(age_group))
    )
  )
```

]

.pull-right[

```{r, eval=T, echo=F}
age_pyramid(
  data = linelist,
  age_group = "age_group",
  split_by = "gender",
  proportional = TRUE,
  show_midpoint = FALSE)+
theme_minimal(base_size = 10)+
labs(
  title = "Age and Gender",
  subtitle = str_glue(
  "Fulton County, reported {min_date} - {max_date}",
  
  min_date = format(
    min(linelist$date_report, na.rm=T),
    "%b %d %Y"),
  
  max_date = format(
    max(linelist$date_report, na.rm=T),
    "%b %d %Y")
  ),
  x = "Percent of total",
  y = "Age group",
  fill = "Gender",
  caption = str_glue(
    "{missing} missing age or gender not shown.",
    missing = fmt_count(
      linelist,
      is.na(gender) | is.na(age_group))
    )
  )
```

]







---

class: medium-table

# Labeling  


.pull-left[
 
To demonstrate labeling points, we create a new dataset that summarizes CFR and median age by race/ethnicity

```{r, echo=T, eval=T}
race_CFR_age <- linelist %>% 
  group_by(eth_race) %>% 
  summarise(
    cases = n(),
    deaths = sum(died_covid == "Yes",
                 na.rm=T),
    CFR = deaths/cases,
    med_age = median(age, na.rm=T)  )
```

]

.pull-right[

```{r, echo=F, eval=T}
head(race_CFR_age, 5) %>% 
  knitr::kable()
```
]








---

# Labeling  

.pull-left[
 
We can plot these data as points, and label them with `geom_text()`... but it does not look very good.  

```{r, echo=T, eval=F}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = eth_race)) +
geom_point() +
*geom_text()
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = eth_race)) +
  geom_point() +
  geom_text()
```

]









---

# Labeling  

.pull-left[
 
Labels look much improved by using `geom_label_repel()` from the **ggrepel** package:  

```{r, echo=T, eval=F}
library(ggrepel)

ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = eth_race)) +     
geom_point() +
*geom_label_repel(         
*   size = 5,               
*   min.segment.length = 0)
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = eth_race)) +
  geom_point() +
 geom_label_repel(
    size = 5,
    min.segment.length = 0)
```

]








---

# Labeling  

.pull-left[
 
`labels=` can be assigned complex values with `str_glue()`:  

```{r, echo=T, eval=F}
library(ggrepel)

ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = str_glue(
*     "{eth_race}\n{cases} cases"))) +
geom_point() +
geom_label_repel(
    size = 5,
    min.segment.length = 0)
```


]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = str_glue(
      "{eth_race}\n{cases} cases"))) +
  geom_point() +
 geom_label_repel(
   size = 5,
   min.segment.length = 0)
```

]






---

# Labeling  

.pull-left[
 
Use `comma()` from the **scales** package to make numbers display with comma separators every three digits.  

```{r, echo=T, eval=F}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
*   label = str_glue(
*     "{eth_race}\n{comma(cases)} cases"))) +
geom_point() +
geom_label_repel(
    size = 4,
    min.segment.length = 0)
```

See the many other useful functions in [**scales**](https://scales.r-lib.org/).  

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(
  data = race_CFR_age,
  mapping = aes(
    x = med_age,
    y = CFR,
    size = cases,
    label = str_glue(
      "{eth_race}\n{comma(cases)} cases"))) +
geom_point() +
geom_label_repel(
   size = 4,
   min.segment.length = 0)
```

]



---

# Marginal distributions  

.pull-left[

Add "marginal" histograms to scatterplots with `ggMarginal()` from the **ggExtra** package.  

```{r, eval=F, echo=T}
scatterplot <- ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) + 
geom_point()
```

```{r, eval=F, echo=T}
ggExtra::ggMarginal(
  scatterplot,                   
  type = "histogram",            
  fill = "lightblue",            
  xparams = list(binwidth = 10), 
  yparams = list(binwidth = 5))  
```
]

.pull-right[
```{r}
scatterplot <- ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp)) + 
geom_point()

ggExtra::ggMarginal(
  scatterplot,                   # add marginal histograms
  type = "histogram",            # specify histograms
  fill = "lightblue",            # bar fill
  xparams = list(binwidth = 10), # other parameters for x-axis marginal
  yparams = list(binwidth = 5))  # other parameters for y-axis marginal
```

]









---
# Combining plots - plot 1

The **cowplot** package facilitates combining multiple plots, while aligning elements such as axes. For date axes, ensure the same limits in both plots.   

```{r, echo=F, message=F, warning=F}
library(cowplot)
```

.pull-left[

Define the first plot.

```{r, echo=T, eval=F, warning=F, message=F}
plot1 <- plot2 <- linelist %>% 
  ggplot(
    mapping = aes(
      x = date_report),
    binwidth = 7)+
  geom_histogram()+
  theme_minimal()+
  scale_y_continuous(expand = c(0,0))+
* scale_x_date(
*   limits = c(
*     as.Date("2020-03-01"),
*     max(linelist$date_report, na.rm=T)),
    date_breaks = "months",
    labels = scales::label_date_short(),
    expand = c(0,0))
```
]

.pull-right[

```{r, echo=F, eval=T, warning=F, message=F}
plot1 <- plot2 <- linelist %>% 
  ggplot(
    mapping = aes(
      x = date_report),
    binwidth = 7)+
  geom_histogram()+
  theme_minimal()+
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),
    limits = c(as.Date("2020-03-01"), max(linelist$date_report, na.rm=T)),
    date_breaks = "months",
    labels = scales::label_date_short())

plot1
```

]

---

# Combining plots - plot 2 

.pull-left[

```{r, echo = T, eval=F}
plot2 <- linelist %>% 
group_by(week = floor_date(date_report, "week")) %>% 
summarise(ci = list(mean_cl_normal(age) %>% rename(mean=y, lwr=ymin, upr=ymax))) %>% 
unnest() %>%  
  
ggplot(
  mapping = aes(
    x = week,
    y = mean,
    ymin = lwr,
    ymax = upr))+
geom_ribbon(alpha = 0.5, fill = "green", color = "green")+
geom_line(size = 2, color = "darkgreen")+
*scale_x_date(
*  limits = c(
*    as.Date("2020-03-01"),
*    max(linelist$date_report, na.rm=T)),
  date_breaks = "months",
  labels = scales::label_date_short(),
  expand = c(0,0))+
coord_cartesian(ylim = c(30, 60))+
theme_minimal()+
labs(
  y = "Weekly mean age (95%CI)",
  x = "Month")
```

]

.pull-right[


```{r, echo = F, eval=T, warning=F, message=F}
plot2 <- linelist %>% 
  group_by(week = floor_date(date_report, "week")) %>% 
  summarise(ci = list(mean_cl_normal(age) %>% rename(mean=y, lwr=ymin, upr=ymax))) %>% 
  unnest() %>%  
  ggplot(
    mapping = aes(
      x = week,
      y = mean,
      ymin = lwr,
      ymax = upr))+
  geom_ribbon(alpha = 0.5, fill = "green", color = "green")+
  geom_line(size = 2, color = "darkgreen")+
  scale_x_date(
    limits = c(as.Date("2020-03-01"), max(linelist$date_report, na.rm=T)),
    expand = c(0,0),
    date_breaks = "months",
    labels = scales::label_date_short()
  )+
  coord_cartesian(ylim = c(30, 60))+
  theme_minimal()+
  labs(
    y = "Weekly mean age (95%CI)",
    x = "Month")

plot2

```

]




---

# Combining plots - result  

```{r, echo = TRUE, fig.height=6, fig.width=9}
plot_grid(plot1, plot2, rel_heights = c(1, 1), ncol = 1, align = "hv")
```



---
# Dual-axis - plot 1  

.pull-left[
You can also use **cowplot** to overlap two plots and create a "dual-axis" plot.  

Define the first plot:  

```{r, eval=F, echo=T}
plot1 <- ggplot(
  data = linelist,
  mapping = aes(
    x = date_report)) + 
geom_histogram(color = "grey",
               alpha = 0.5) +
*theme_cowplot() +
*scale_x_date(
* limits = c(
*   as.Date("2020-03-01"),
*   max(linelist$date_report, na.rm = TRUE)),  
  date_breaks = "months",
  labels = scales::label_date_short(),
  expand = c(0, 0),
  name = "") +
scale_y_continuous(
  expand = c(0,0),
  name   = "Weekly reported case incidence")
```
]


.pull-right[

```{r, eval=T, echo=F}
plot1 <- ggplot(
  data = linelist,
  mapping = aes(
    x = date_report)) + 
geom_histogram(color = "grey", alpha = 0.5)+
theme_cowplot()+
scale_x_date(
 limits = c(
   as.Date("2020-03-01"),
   max(linelist$date_report, na.rm=T)),  
  date_breaks = "months",
  labels = scales::label_date_short(),
  expand = c(0,0),
  name = "")+
scale_y_continuous(
  expand = c(0,0),
  name = "Weekly reported case incidence")
plot1
```

]


---

# Dual-axis - plot 2

.pull-left[

```{r, eval=F, echo=T}
plot2 <- linelist %>% 
  group_by(epiweek) %>% 
  summarise(CFR = sum(died == "Yes", na.rm=T) / n() ) %>% 
ggplot(
  mapping = aes(
    x = epiweek,
    y = CFR))+
    geom_line(size = 2, color = "orange")+
* theme_cowplot()+
  scale_y_continuous(
*   position = "right",
    limits = c(0, 0.2),
    expand = c(0,0),
    name = "Weekly CFR")+
* scale_x_date(
*   limits = c(
*     as.Date("2020-03-01"),
*     max(linelist$date_report, na.rm=T)),  
    date_breaks = "months",
    labels = scales::label_date_short(),
    expand = c(0,0),
    name = "Epiweek")+
  theme(
    axis.text.y = element_text(color = "orange", face = "bold"),
    axis.title.y = element_text(color = "orange", face = "bold"))
```

]

.pull-right[

```{r, eval=T, echo=F}
plot2 <- linelist %>% 
  group_by(epiweek) %>% 
  summarise(CFR = sum(died == "Yes", na.rm=T) / n() ) %>% 
ggplot(
  mapping = aes(
    x = epiweek,
    y = CFR))+
    geom_line(size = 2, color = "orange")+
  theme_cowplot()+
  scale_y_continuous(
    position = "right",
    limits = c(0, 0.2),
    expand = c(0,0),
    name = "Weekly CFR")+
  scale_x_date(
    limits = c(as.Date("2020-03-01"), max(linelist$date_report, na.rm=T)),  
    date_breaks = "months",
    labels = scales::label_date_short(),
    expand = c(0,0),
    name = "Epiweek")+
  theme(
    axis.text.y = element_text(color = "orange", face = "bold"),
    axis.title.y = element_text(color = "orange", face = "bold"))
plot2
```

]


---

# Dual-axis - combined

```{r echo = TRUE, fig.width=9, fig.height=6}
aligned  <- align_plots(plot1, plot2, align = "hv")
combined <- ggdraw(aligned[[1]]) + draw_plot(aligned[[2]])
combined
```



---

# Interactive plots  

Use `ggplotly()` from the **plotly** package to easily make most ggplots interactive.  

```{r echo = F, eval=T, fig.width=9, fig.height=6}
bar_plot <- ggplot(
  data = linelist,
  mapping = aes(x = eth_race, fill = died)) +             
geom_bar() + 
theme(axis.text.x = element_text(angle=30))
```

```{r echo = T, eval=T, fig.width=9, fig.height=6}
# Provide the name of a defined plot into ggplotly()  
plotly::ggplotly(bar_plot)
```




---

# Data structure  

**ggplot2** works best when the dataset is in "long" format, where each variable has its own column. We recommend that you become familiar with `pivot_longer()` from **dplyr** (see the [Epi R Handbook pivoting page](https://epirhandbook.com/pivoting-data.html)).  
   

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/pivoting.png?raw=true")
```






---

# Helpful charts  

.pull-left[

For color & fill use names or hex code  

```{r, eval = TRUE, echo = FALSE, fig.height=4}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/ggplot_colors.png?raw=true")
```
]

.pull-right[

For shapes, try these numeric codes:  

```{r, eval = TRUE, echo = FALSE}
knitr::include_graphics("https://github.com/appliedepi/emory_training/blob/master/presentation/images/ggplot_shapes.png?raw=true")
```
]




---
class: inverse, center, middle

# Geographic Information Systems (GIS) 
### An introduction with R 

---
# Shapefiles 
.pull-left[
- Multiple layers make file 
- Made up of: 
  - Points, lines, polygons
- handled with [{sf}](https://r-spatial.github.io/sf/) package
  - simple features:
   make things much more simple!
  - Can use tidyverse syntax as if dataframes
- Other formats exist (e.g. GeoJson)
]

.pull-right[
![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/shapefiles.png?raw=true)
]

.footnote[
See the [EpiRHandbook section on GIS basics](https://epirhandbook.com/gis-basics.html)
]

???
Until a few years ago geospatial work in R was very painful - but with SF it has
now become as easy as dataframes in tidyverse! 

---
# Import shapefile 


```{r import_shp, echo = TRUE}
# import shapefile
shapefile <- read_sf(
  # define path to file
  here::here("case_study", "data", "covid_example_data", "covid_shapefile", 
             "FultonCountyZipCodes.shp")
)

```

```{r show_shp, highlight.output=c(5)}
shapefile
```


???
We can see here that the CRS is specific to Georgia (so doesn't play well with GPS points)

---
# Coordinate reference systems


<iframe width="100%" height="676" frameborder="0"
  src="https://observablehq.com/embed/@d3/projection-transitions?cells=viewof+context"></iframe>

.footnote[
Source: [Mike Bostock]("https://twitter.com/mbostock/status/1292887409474994176")
]

---
# Changing the CRS 

```{r change_crs, echo = TRUE}

# change shapefile coordinate reference system to WGS84
shapefile <- st_transform(shapefile, crs = 4326)

```


```{r show_shp_reproj, highlight.output=c(5)}

shapefile
```

???
We can use sf::st_transform to re-project a spatial object 
We can use sf::st_crs to check (or set) the crs for a spatial object

---
# Take a look!

.pull-left[
```{r plot_shp, echo = TRUE, eval = FALSE}

# open up a ggplot
ggplot() + 
  # add the shapefile on top
  geom_sf(data = shapefile, 
          # no fill
          fill = NA,
          # black borders
          colour = "black") 

```
]

.pull-right[
```{r plot_shp_show}

# open up a ggplot
ggplot() + 
  # add the shapefile on top with no fill and black borders
  geom_sf(data = shapefile, fill = NA, colour = "black") 

```
]
---
# Set CRS for point coordinates

```{r cases_crs, echo = TRUE}

# define period of interest
recent_period   <- seq(as.Date("2021-06-30") - 13, as.Date("2021-06-30"), by = 1)

# convert linelist data frame into sf object (with georeference points)
linelist_sf <- linelist %>%
  # remove rows missing gps coordinates
  drop_na(lat, lon) %>%
  filter(
    # drop those with wrong GPS points
    lat >= 33 & lat <= 35,
    lon >= -85 & lon <= -84,
    # drop those outside the last 2 weeks 
    date_report %in% recent_period
  ) %>%
  # create an sf object
  st_as_sf(                                               #<<
    # define the coordinates based on lat/long variables
    coords = c("lon", "lat"),                             #<<
    # set the coordinate reference system to WGS84
    crs = 4326,                                           #<<
    # do not change string variables to factors 
    stringsAsFactors = FALSE                              #<<
  )
```

---
# Set CRS for point coordinates

```{r view_llsf}

# view the first ten rows of linelist with the geometry column
linelist_sf %>% 
  select(1:5, geometry, -date_dob)

```

---
# Basemaps 

- A screenshot of the map area 
- Called tiles 
  - Smaller images pieced together 
- Added for context (bottom layer of *ggplot*)
- A lot of different tile servers 
- A lot of different R packages 
  - We demonstrate [{ggspatial}](https://paleolimbot.github.io/ggspatial/)
    - Able to save tiles for offline use 
    - Also have scalebars 

---
# Bounding boxes

![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/bounding_box.png?raw=true)

---
# Download & plot basemap

.pull-left[
```{r basemap, echo = TRUE}
# get the bounding box for the shapefile 
bounding_box <- shapefile %>% 
  st_bbox()

# plot a base map including scale bar 
basemap <- ggplot() +
  # change the bounding box to an sf object
  # this defines the area to download map tiles for
  geom_sf(data = st_as_sfc(bounding_box)) +
  # download map tiles and add to the plot
  annotation_map_tile(                               #<<
    # define what map tiles to use
    type =  "cartolight",
    # define folder to store tile images 
    cachedir = here::here("data", "map_tiles"),
    # define if should download tiles each time
    forcedownload = FALSE,
    # hide messages about download status and zoom
    progress = "none" ) 
```
]

.pull-right[
```{r basemap_show}
basemap
```
]

---
# Points 

.pull-left[
```{r points_map, echo = TRUE}

# plot the basemap 
points_map <- basemap + 
  # add the shapefile on top with no fill and black borders
  geom_sf(data = shapefile, 
          fill = NA, 
          colour = "black") +
  # plot points from linelist coloured by ethnicity
  # (order the factor so that the most frequent group is plotted first)
  geom_sf(data = linelist_sf, 
          mapping = aes(colour = fct_infreq(eth_race))) + 
  # choose colour combination 
  scale_colour_brewer(palette = "Set1") +
  # change the legend label
  labs(colour = "Ethnicity") + 
  theme(legend.position = "bottom")

```
]

.pull-right[
```{r points_map_show}
points_map

```
]


---
# Choropleths - prepare data

```{r choropleths_data, echo = TRUE}


# get counts of points within polygons
shapefile <- shapefile %>%
  # add a column to the shapefile with counts
  mutate(
    # see which points are in which zip code polygon
    cases = st_intersects(., linelist_sf) %>%           #<<
            # count how many are in each
            lengths()                                   #<<
    )


# calculate incidence in shapefiledata
shapefile <- shapefile %>% 
  mutate(
    # divide cases by population 
    incidence = round(cases / Population * 100000, digits = 1), 
    # clean up calculations 
    incidence = case_when(
           # fix the outliers: set infinity to NA and cases less than 10 to NA
           cases < 5              ~ NA_real_,
           is.infinite(incidence) ~ NA_real_,  ## nb. infinite due to zero denominator
           TRUE                   ~ incidence)
    )



```

---
# Choropleths - prepare data

```{r choropleths_data_two, echo = TRUE}

# define breaks (for plotting groups)
breakers <- shapefile %>% 
  # change shapefile to a tibble (otherwise geometry pulled with)
  as_tibble() %>% 
  # only keep zips with more than ten cases
  filter(cases > 5) %>% 
  # pull the incidence column
  select(incidence) %>% 
  # define grouping cut-offs based on quartiles of observations 
  quantile(probs = seq(0, 1, 0.25), na.rm = TRUE) 

# create a factor variable for incidence
shapefile <- shapefile %>% 
  mutate(                                                               #<< 
    # define groups using the cut function       
    incidence_cats = cut(incidence,                                       
                         # cut-offs as defined above (including zero)
                         breaks = c(0, breakers), 
                         # add labels by using the cut-offs
                         labels = str_glue("<={breakers}"))
    )
```


---
# Choropleths - plot data

.pull-left[
```{r choropleths_plot, echo = TRUE}
# plot basemap 
choropleth <- basemap + 
  # add in shapefile (with black borders) colour by incidence categories
  geom_sf(data = shapefile, 
          aes(fill = incidence_cats),
          colour = "black") + 
  # define colour scheme 
  scale_fill_brewer(palette = "YlGn", 
                    # edit legend labels to the categories defined
                    # rename the missing group to be fewer than 10 cases
                    labels = c(
                      levels(shapefile$incidence_cats),
                      "Fewer than 5 cases")) + 
  # add in text labels for each zip code 
  geom_sf_text(data = shapefile, 
               aes(label = ZipCode), 
               check_overlap = TRUE) + 
  # change the legend title 
  labs(fill = "Confirmed cases per \n 100,000 by Zip code")
```
]

.pull-right[
```{r choropleths_plot_show}
choropleth
```
]


---
# Bivariate choropleths 
- Placeholder for demo > see case study [weekly_report.Rmd](https://github.com/appliedepi/emory_training/blob/master/case_study/weekly_report.Rmd#L1894) for details 

```{r load_patchork}
## loaded here only because conflicts with cowplot
pacman::p_load(
  patchwork   # combine plots
)
```


.center[
```{r bivarmap_demo}

# prepare data for plotting 
#############################


shapefile <- shapefile %>%
  mutate(
    # get counts of the number of non-white cases in each polygon
    case_eth = st_intersects(.,
                           filter(
                             linelist_sf,
                             eth_race != "White, NH"
                             )) %>%
                            lengths(),
    case_eth_perc = case_eth / cases * 100, 
    case_eth_perc = if_else(case_eth == 0, 0, case_eth_perc),
    case_eth_cats = cut(case_eth_perc, 
                        breaks = c(0, 1, 25, 50, 75, 100), 
                        include.lowest = TRUE,
                        labels = c("0%", "25%", "50%", "75%", "100%")), 
    incidence_cats = fct_explicit_na(incidence_cats, 
                                     na_level = "Under 10 cases"), 
    incidence_cats = fct_relevel(incidence_cats, 
                                 "Under 10 cases", 
                                 after = 0)
    )


# define your colour palette  
col_grps <- make_colours(
  og_pal1 = "PinkYl", 
  og_pal2 = "YlGnBu",
  num1 = 6,
  num2 = 5)

# create a unique identifier by combining the row and columnn labels
col_grps <- col_grps %>% 
  mutate(merger = str_glue("{rws}-{cls}")) 

# create a unique identifier by combining category levels in shapefile
shapefile <- shapefile %>% 
  mutate(merger = str_glue("{as.numeric(incidence_cats)}-{as.numeric(case_eth_cats)}"))


# join colours to shapefile 
shapefile <- left_join(shapefile, col_grps, by = "merger")


# plot bivariate choropleth map 
###############################

bivar_map <- basemap + 
  # fill shape with the colours column 
  geom_sf(data = shapefile, 
          aes(fill = clrs), 
          color = "black", 
          size = 0.1) + 
  # fill polygons by the colours as they are named clrs column
  scale_fill_identity(drop = FALSE, 
          na.value = "grey90") + 
  theme_void()




# plot the legend separately 
# use the col_grps dataset (colour scheme generated by make_colours function)
# use the counts for rows and columns and fill by the clrs columns
legend <- ggplot(
    data = col_grps,
    mapping = aes(
      x = cls,
      y = rws,
      fill = clrs)) +
  # create a tile plot (boxes)
  geom_tile() +
  # fill tiles by the colour names in clr 
  scale_fill_identity() + 
  # label the axis ticks from 0 to the number of levels
  scale_x_continuous(
    breaks = c(1:5),
    labels = levels(shapefile$case_eth_cats), 
    ) +
  scale_y_continuous(
    breaks = c(1:6),
    labels = levels(shapefile$incidence_cats)
    ) +
  # make tiles boxes
  coord_fixed() + 
  # label axes 
  labs(x = "Ethnic minorities (%)", y = "Incidence (per 100k)") + 
  # make simple theme and set text size 
  theme_minimal(base_size = 18) + 
  # rotate the xaxis labels 
  theme(axis.text.x = element_text(angle = 45))




# using {patchwork} - set the plot layout area 
# The map goes from top left at 1,1 to bottom right at 10,10
# the legend sits within that as a smaller box 
# (think of this as upside-down cartesian coordinates)
layout <- c(
  area(t = 1, l = 1, b = 10, r = 10),
  area(t = 1, l = 2, b = 4, r = 4)
  )


# combine the map and the legend with the above layout
bivar_map + legend + plot_layout(design = layout)
```
]


---
# Heatmaps 

![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/heatmap.png?raw=true)

---
# Heatmaps - distance
- How many x-units in one kilometre? 

.pull-left[
![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/axis_distance.png?raw=true)
]

.pull-right[

$$x_{units} = \frac{x_{max}-x_{min}}{x_{metres}}$$
]

---
# Heatmaps - calculating 

```{r heatmaps_distance, echo = TRUE}

# define x and y minimum/maximum coordinates based on bounding box of base map
xmin <- st_point(c(bounding_box$xmin, bounding_box$ymin))
xmax <- st_point(c(bounding_box$xmax, bounding_box$ymin))
ymin <- xmin
ymax <- st_point(c(bounding_box$xmin, bounding_box$ymax))
                 

# create sf points (with coordinate reference system WGS84) for the x and y axis
xaxis <- st_sfc(xmin, xmax, crs = 4326)
yaxis <- st_sfc(ymin, ymax, crs = 4326)
                 
# calculate the distance in metres on the axes of your based on longitude and latitude
# i.e. how many metres on your x axis and how many on your y
xdist <- st_distance(xaxis)[2] %>% units::set_units("miles")      #<<
ydist <- st_distance(yaxis)[2] %>% units::set_units("miles")      #<<

# calculate how many lat/long units there are on each axis 
xunits <- st_distance(xmin, xmax)                                 #<<
yunits <- st_distance(ymin, ymax)                                 #<<


# divide the difference in latitude or longitude by the corresponding distance
# returns the number of units per distance of interest (i.e. coord units per mile)
xfact <- as.numeric(xunits / xdist)                               #<<
yfact <- as.numeric(yunits / ydist)                               #<<
```


---
# Heatmaps - plotting 

.pull-left[
```{r heatmaps_plotting, echo = TRUE}
heatmap <- basemap + 
  # add in shapefile not filled with black border
  geom_sf(data = shapefile, fill = NA, colour = "black") +
  # add in a density layer 
  stat_density_2d(
        # using the sf formatted linelist
        data = linelist_sf,
        aes(
          # extract the lat lon from geometry (list column)
          x = purrr::map_dbl(geometry, ~.[1]),
          y = purrr::map_dbl(geometry, ~.[2]), 
          # fill based on the calculated density
          fill = after_stat(level)
          ),
        # define the shape to use for smoothing
        geom = "polygon",
        # define whether to show legend (removed as uninformative)
        show.legend = FALSE,
        # bandwith (distance squared) 
        h = c(xfact, yfact)
        ) + 
  # define fill palette (viridis continuous) 
  scale_fill_viridis_c(option = "C")
```
]

.pull-right[
```{r heatmaps_plotting_show}
heatmap + theme_void()
```
]

---
# Thank you  

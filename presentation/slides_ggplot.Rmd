---
title: "Emory COVID-19 Response Collaborative"
subtitle: "Data visualization with ggplot2: an overview and demonstration"
author: '[EpiRhandbook Team](https:://epirhandbook.com) <br><br> `r icons::icon_style(icons::fontawesome("twitter"), fill = "white")` [epiRhandbook](https://twitter.com/epiRhandbook) <br> `r icons::icon_style(icons::fontawesome("paper-plane"), fill = "white")` [epirhandbook@gmail.com](mailto:epirhandbook@gmail.com)'
date: "August 2021"
output:
  xaringan::moon_reader:
    self_contained: FALSE
    seal: TRUE
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
---

```{r, echo=F}
# You need to run this line once, for the slides to render 
# icons::download_fontawesome()

# Use this command to run preview-mode in RStudio. Save Rmd to update slide preview
# xaringan::inf_mr()
```


```{css, echo = F}
/* THIS IS A CSS CHUNK - THIS IS A COMMENT */

/* Size of font in code echo. E.g. 10px or 50% */
.remark-code {
  font-size: 70%;
}


/* Size of font in text */

.medium-text {
  font-size: 75%;     
}

/* Size of font in tables */

.small-table table {
  font-size: 6px;     
}

.medium-table table {
  font-size: 8px;     
}

.medium-large-table table {
  font-size: 10px;     
}

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.retina = 3  ## retina more effective than w/h (according to twitter)
                      # fig.width = 16, 
                      # fig.height = 10
                      )

## I dont know why this is included in the example xaringan slide 
## but is something to do with background images
options(htmltools.dir.version = FALSE)
```


```{r}
## install and load necessary packages 
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  skimr,      # review data
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  tidyverse,  # data management and visualization
  xaringanthemer  # for styling presentation 
)

```


```{r xaringan-themer, include = FALSE}

## define presentation colours (theme) using {xaringanthemer} package 
## https://pkg.garrickadenbuie.com/xaringanthemer/articles/xaringanthemer.html

## epirhandbook logo colours: 
  ## blue: "#00538c"
  ## green: "#007732"
  ## lighter green: "#48a878"

## see ?style_mono_accent for all the things can customise
style_mono_accent(
  base_color = "#00538c", 
  link_color = "#48a878", 
  ## add logo to the title page (bit bigger)
  title_slide_background_image = "https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/epiRhandbook_HexSticker_500x500.png", 
  title_slide_background_position = "100% 100%", 
  title_slide_background_size = "25%", 
  ## add logo to all following slides
  background_image = "https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/epiRhandbook_HexSticker_500x500.png", 
  background_size = "10%",
  background_position = "100% 0%"
)

```


# We are Applied Epi  

![](https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/Epi%20R%20Handbook%20Banner%20Beige%201500x500.png)

* We are a grassroots collaborative of applied epidemiologists  
* Our (free) **Epi R Handbook** has been used by 40,000 people worldwide
* Now we offer customized training to health departments and NGOs  


.footnote[Bookmark [www.epiRhandbook.com](www.epirhandbook.com)!]  


???
- What makes us different is that we focus on the challenges of applied epi, not academic epi. We emphasize the skills used every day by ground-level epidemiologists. 


---
# Introducing ourselves  

* Neale Batra  
 - Founder of Epi R Handbook. Previously epi and preparedness at Philly and Santa Clara County health departments. Currently working for WHO Geneva COVID-19 analytics team  
* Alex Spina  
 - Alum of EPIET (European EIS). MSF Epi. WHO AFRO. Med Student. 
* Mathilde Mousset  
 - Epicentre (MSF). Ecology. 

(PHOTOS AND BIOS)  


---
# Today's session   

Today is primarily *explanation* and *demonstration*, following from the previous [demonstration on data management and workflow](https://appliedepi.github.io/emory_training/presentation/slides.html).  

We assume you have reviewed the Handbook pages on [R Basics](https://epirhandbook.com/r-basics.html) and [ggplot basics](https://epirhandbook.com/ggplot-basics.html).  

![](https://github.com/appliedepi/emory_training/blob/master/presentation/images/EDGE.png?raw=true)  




???
- The learning process can be summarised into this acronym "EDGE". Today's session is primarily a *demonstration* with question & answer session. We assume that you have read at least some of the relevant pages in the Epi R Handbook prior to this session. We also offer trainings in which we guide you through case studies with hands-on coaching. 


---
# Outline

1) Setting the scene (directory, packages, data import)  
2) Fundamentals of ggplot  
3) Bar charts  
4) Epidemic curves  
5) Demographic pyramids  
6) Scatter plots  
7) Plot captions  

The Epi R Handbook contains more examples and more complex plots, for your personal reading  







---
# Visualization options in R  

Today we focus on **ggplot2** because:  

* It is good for fast data exploration of multi-dimensional data  
* It produces very high quality final outputs  
* Is accompanied by many packages that expand functionality  
* Has well-structured grammar = consistency  

Other plotting options include [**base** R](https://towardsdatascience.com/base-plotting-in-r-eb365da06b22), [**lattice**](https://www.statmethods.net/advgraphs/trellis.html), and [**plotly**](https://plotly.com/r/).  












---
# Setting the scene - directory structure  

Our R work is conducted within a dedicated directory that contains:  

* An R project (optional but advised)  
* R markdown scripts  
* A data folder  

* R project (`case_study.Rproj`)  
  * `data/` folder  
    * `covid_example_data/` folder
      * `covid_example_data.xlsx`  
      * `covid_shapefile/` folder  
        - `FultonCountryZipCode.shp`...
  * `scripts/` folder  
    * `ggplot_demo.Rmd`

```{r, echo = F, eval=F}
fs::dir_tree(path = here::here("case_study", "data", "covid_example_data"), recurse = TRUE)
```








---
# Load packages  

**ggplot2** is included within the **tidyverse** mega-package (read more [here](https://www.tidyverse.org/)).  

```{r, eval = FALSE, echo=TRUE}
pacman::p_load(
  rio,            # import/export
  here,           # file locator
  rmarkdown,      # reports
  lubridate,      # working with dates
  tidyverse       # mega-package for data management and visualization
  )
```

The **tidyverse** also includes these packages:  
* **dplyr** (data management)  
* **stringr** (characters and text)  
* **forcats** (factors / ordered categories)  
* and many others...  








---

# Import data

We use a *clean* dataset, to focus on visualization techniques.  

* Use `import()` from **rio** to import a file  
* Use `here()` from **here** to locate the file relative to the R project root

```{r echo=FALSE, eval=TRUE}
# This actually runs but is not displayed
linelist_raw <- rio::import(here::here("case_study", "data", "covid_example_data", "covid_example_data.xlsx"))
```

```{r echo=TRUE, eval=FALSE}
linelist_raw <- import(here("case_study", "data", "covid_example_data", "covid_example_data.xlsx"))
```

*Note: The `import()` function can import almost any kind of file. A .rds file stores an R data frame and retains column classes*  



---

class: remark-code

# Clean data  

See the [RMD FROM PREVIOUS SESSION] for all the cleaning code. We will not linger on this today in the interest of time.    

```{r, echo=F}
linelist <- linelist_raw %>% 
  filter(confirmed_case == "Yes") %>% 
  
  select(                                       # use select() to retain columns
    date_report  = reprt_creationdt_FALSE,      # (it can also be used to re-name)
    date_dob     = case_dob_FALSE,              # NEW name = OLD name
    age          = case_age,                    # aligned for readability
    gender       = case_gender,
    zip          = case_zip,
    eth          = case_eth,
    race         = case_race,
    Contact_id, 
    date_onset   = sym_startdt_FALSE,
    sym_fever,
    sym_cough,
    sym_headache,
    sym_losstastesmell,
    sym_sorethroat,
    sym_myalgia,
    contact_hh        = contact_household,
    hospitalized,
    date_hospitalized = hosp_admidt_FALSE,
    date_discharge    = hosp_dischdt_FALSE,
    died,
    died_covid,
    date_died         = died_dt_FALSE,
    lat               = latitude_JITT,
    lon               = longitude_JITT) %>% 
  
  # convert column classes
  mutate(age = as.numeric(age)) %>%             # convert class
  mutate(zip = as_factor(zip)) %>% 
  mutate(across(contains("date"), ymd)) %>%     # convert all date columns, ymd() from lubridate

  # clean died column
  mutate(
    died = fct_explicit_na(died, na_level = "Unknown"),
    died = fct_relevel(died, "Yes", "No", "Unknown")
    ) %>% 
  
  # remove onset dates prior to 2020
  mutate(across(
    .cols = c(date_report, date_onset, date_hospitalized, date_discharge, date_died),
    .fns  = ~ replace(.x, .x < as.Date("2020-01-01"), NA)
    ))%>% 
  
  # Remove dates after today from all date columns
  mutate(across(
    .cols = contains("date"),
    .fns  =  ~ replace(.x, .x > Sys.Date(), NA)
    )) %>% 
  
  # delay onset to hospitalization
  mutate(
    days_onset_hosp = as.numeric(date_hospitalized - date_onset),
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp < 0, NA),
    days_onset_hosp = replace(days_onset_hosp, days_onset_hosp > 30, NA)
    ) %>% 

  # length hospitalization
  mutate(
    date_outcome = coalesce(date_died, date_discharge),
    days_hosp = as.numeric(date_outcome - date_hospitalized),
    days_hosp = replace(days_hosp, days_hosp < 0, NA),
    days_hosp = replace(days_hosp, days_hosp > 60, NA)
    ) %>% 
  
  mutate(eth_race = case_when(
          eth == "HISPANIC/LATINO"                            ~ "Hispanic, all races", 
          race == "ASIAN" & 
               eth != "HISPANIC/LATINO"                       ~ "Asian, NH", 
          race == "BLACK" & 
               eth != "HISPANIC/LATINO"                       ~ "Black, NH",
          race == "WHITE" & 
               eth != "HISPANIC/LATINO"                       ~ "White, NH",
          race == "AMERICAN INDIAN/ALASKA NATIVE" |
               race == "NATIVE HAWAIIAN/PACIFIC ISLANDER" |
               race == "OTHER" & 
               eth != "HISPANIC/LATINO"                       ~ "Other, NH", 
          TRUE                                                ~ "Unknown"
     )) %>% 
  # set levels of a factor (define order)
     mutate(gender      = fct_relevel(gender, "Female", "Male", "Unknown"), 
            eth_race    = fct_relevel(eth_race, 
                                   "Asian, NH", "Black, NH", "White, NH", 
                                   "Hispanic, all races", "Other, NH", "Unknown")
         )

```





---

class: small-table

# Review data  


```{r, echo=T}
# You can use `skim()` from the skimr package.  
skim(linelist) %>% 
  filter(skim_type == "character")
```

---

class: small-table

# Review data  

```{r, echo=T}
skimr::skim(linelist) %>% 
  filter(skim_type == "Date")
```


---

class: small-table

# Review data  

```{r, echo=T}
skimr::skim(linelist) %>% 
  filter(skim_type == "numeric")
```





---

class: small-table

# Review data  

Below are the first rows of the `linelist` data frame:  

```{r}
head(linelist, 25) %>% 
  DT::datatable(
    options = list(
      scrollY = 300,
      scrollX = 600,
      pageLength = 25,
      fontSize = '25%',
      dom = "ti",
      ordering = FALSE,
      rownames = FALSE,
      options = list(pageLength = 5, scrollX=T),
      class = 'white-space: nowrap' 
    )
  )

  #knitr::kable(format = 'html')
```





---
# Fundamentals of ggplot2





---
# gg-what??  

- The **ggplot2** *package* is the most popular data visualization tool in R  
- Its `ggplot()` *function* is at the core of the package  
- This whole approach is colloquially known as “ggploting”  
- Resulting figures are sometimes affectionately called “ggplots”  

**ggplot2** benefits from a wide variety of supplementary R packages that extends its functionalities, such as **gganimate**, **ggthemr**, **ggdendro**, **gghighlight**, **ggforce**...  

.footnote[
Question: What does the "gg” in these names represent?
]

???
- "gg" represents the “grammar of graphics” used to construct the figures 





---
# Syntax overview  

Build a plot object by “adding” commands that specify plot layers and design elements on top of one another  
 

--

Order of layers will usually look like this:

1) **"Open" the plot** with the `ggplot()` command and specify the dataset  

--

2) **Add (`+`) “geom” layers** that visualize data geometrically as shapes  

--

3) **"Map" data columns** to features of the plot such as axes, color, size, shape, fill, transparency  


--

4) **Modify "scales"**, such as a color scale  

--

5) **Add design elements** such as axis labels, title, fonts, text sizes, background themes, or axes rotation  

--

All these layers are "added" sequentially with a `+` symbol  







---
# Syntax - open the plot  

.pull-left[

`ggplot()` creates an empty canvas.  
Assign the data frame to use.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)                   
```

Alternatively, use the `%>%` pipe operator to "pipe" a data frame *into* `ggplot()`  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
linelist %>%
  ggplot()
```

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist)
```
] 

???
This is only a blank canvas, we have not defined what should be in the x and y axes. 
If several data frames are needed, they can be added in their own geoms.
Piping is useful to make one-time changes to a dataset prior to plotting.  





---
# Geometries  

.pull-left[

Data are visualized using "geom" commands, such as `geom_point()`.  

Some classical “geoms” include:  

Geometry        |Geom                
----------------|--------------------
Histograms      |`geom_histogram()`
Points          |`geom_point()`  
Lines           |`geom_line()`  
Box plots       |`geom_boxplot()`  
Bar charts      |`geom_bar()` or `geom_col()`  
Trend lines     |`geom_smooth()`  

Full list [here](https://ggplot2.tidyverse.org/reference/)  

]


.pull-right[

```{r, message=F, warning=F}

# Histogram
histogram <- ggplot(
    data = linelist,
    mapping = aes(
      x = date_onset))+
  geom_histogram(fill = "darkorange")+
  labs(title = "geom_histogram()")+
  theme_minimal()
  

points <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_hosp)
    )+
  geom_point()+
  labs(title = "geom_point()")+
  theme_minimal()


smooth <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_onset_hosp)
    )+
  geom_smooth()+
  labs(title = "geom_smooth()")+
  theme_minimal()



density <- ggplot(
    data = linelist,
    mapping = aes(
      x = age,       
      y = days_hosp)
    )+
  geom_density2d_filled()+
  labs(title = "geom_density2d_filled()")+
  theme_minimal()

  
lines <- linelist %>% 
  group_by(eth_race,
           week_report = lubridate::floor_date(date_report, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_report) %>% 
  ggplot(
    mapping = aes(
      x = week_report,       
      y = n_cases,
      color = eth_race),
    size = 4
    )+
  geom_line()+
  labs(title = "geom_line()")+
  theme_minimal()



boxplots <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = age)
    )+
  geom_boxplot()+
  labs(title = "geom_boxplot()")+
  theme_minimal()



violins <- ggplot(
    data = linelist,
    mapping = aes(
      x = died,       
      y = days_hosp,
      fill = died)
    )+
  geom_violin()+
  labs(title = "geom_violin()")+
  theme_minimal()


bars <- linelist %>% 
  ggplot(mapping = aes(
      y = died,
      fill = died))+
  geom_bar()+
  labs(title = "geom_bar()")+
  theme_minimal()+
  theme(legend.position = "none")


top <- cowplot::plot_grid(histogram, points,
                          boxplots, bars,
                          #smooth, density,
                          
                          nrow = 2, rel_widths = c(2,2))

cowplot::plot_grid(top, lines, ncol = 1)

```

]






---
# Plot aesthetics  

.pull-left[

What else is missing from this command to create a scatter plot (points)?  

```{r, eval=F, echo=T}
ggplot(data = linelist)+
  geom_point()
```

**What columns should be used for axes?**  

**How should the points be colored, shaped, etc?**  

These are the plot's "aesthetics"  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist)
```

]



---
# Mapping aesthetics with `aes()`  

.pull-left[

`mapping = aes()` is a `ggplot()` argument that assigns columns to plot "aesthetics" - features *whose display could vary for each data point* (position, color, shape...)  

It is unique in that its inputs must be placed within `aes()`.  

Two basic aesthetic mappings are the axes: `x=` and `y=`.  

```{r, eval=F, echo=T}
ggplot(
  data = linelist,
  mapping = aes(x = age, y = days_hosp)
  )
```



]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))
```
] 


---
# A quick note on indentations  

Indentations, spaces, and newlines do not impact code execution, and can be varied to improve readability.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist, mapping = aes(x = age, y = days_hosp))+
  geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(x = age, y = days_hosp))+
  geom_point()
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,        # use case linelist
  mapping = aes(          # make aesthetic mappings for all geoms
    x = age,              # assign x-axis to age column
    y = days_hosp))+      # assign y-axis to duration of hospitalization
geom_point()              # display data as points
```



???
- Explain why you might use one or the other 
long style can enable informative comments/annotations  










---
# Aesthetic mapping placement  

* Mappings written in `ggplot()` apply to all geoms (e.g. axes)  
* Mappings written within one geom apply only to it  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(                     # open the plot 
  data = linelist,            # set dataset 
* mapping = aes(              # map axes to columns
*   x = age,
*   y = days_hosp))+
  geom_point()              # plot points
```

is the same as:  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)+    # open plot and set dataset
  geom_point(               # plot points
*    mapping = aes(           # map axes to columns
*      x = age,
*      y = days_hosp))
```

(but only because there is only one geom)  


???
- Explain why you might use one or the other  








---
# Overplotting  

.pull-left[

With axes now mapped, the `geom_point()` displays the data as points

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = onset_hosp))+
*  geom_point()
```

This plot is difficult to interpret because points may be overlapping.  

*tip: try `geom_jitter()` to slightly offset all points*  

]

.pull-right[


```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))+
  geom_point()
```

] 


















---
# Adding geoms  

.pull-left[

Additional geoms can be added on top  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))+
  geom_point()+
* geom_smooth()
```

`geom_smooth()` gives smoothed conditional means, helping to show trends in presence of "over-plotting" (see [documentation](https://ggplot2.tidyverse.org/reference/geom_smooth.html)).  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp))+
  geom_point()+
  geom_smooth()
```
] 

???
- Explain why you might use one or the other  






---

class: medium-large-table

# Other aesthetics  



.pull-left[
Aside from axes, other common "aesthetics" include: 

Geometry        |Geom                
----------------|--------------------
`shape = `      |Display point as dot, star, triangle, square...
`fill =  `      |The *interior* color (e.g of bar or boxplot)  
`color = `      |The *exterior* or bar, boxplot - OR point color  
`size = `       |Line thickness, point size...
`alpha = `      |Transparency (1 = opaque, 0 = invisible)
`width = `      |Width of "bar plot" bars
`linetype = `   |Either solid, dashed, dotted, etc.  
`binwidth = `   |Width of histogram bins  
  

]


.pull-right[
Some examples: 
```{r, message=F, warning=F}

shape_3 <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(shape = 3)+
  theme_minimal()+
  labs(title = "shape = 3")

shape_died <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(aes(shape = died))+
  theme_minimal()+
  labs(title = "aes(shape = died)")

###

fill_purple <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(fill = "purple")+
  theme_minimal()+
  labs(title = "fill = 'purple'")


fill_died <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(aes(fill = died))+
    theme_minimal()+
  labs(title = "aes(fill = died)")

###

col <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(fill = "lightgreen", color = "purple")+
  theme_minimal()+
  labs(title = "fill = 'lightgreen', color = 'purple'")


col_died <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(aes(fill = died), color = "black")+
  theme_minimal()+
  labs(title = "aes(fill = died), color = 'black'")


cowplot::plot_grid(shape_3, shape_died,
                  fill_purple, fill_died,
                   col, col_died,
                   ncol = 2, rel_widths = c(2,2))


```

]



???

Note that “aesthetic” in ggplot has a specific meaning that you might associate with the word “aesthetics” in common English. In ggplot those details are called “themes” and are adjusted within a theme() command

Each geom accepts certain aesthetics, like `binwidth=` for `geom_histogram()`









---

class: medium-text

# Other aesthetics  



.pull-left[

These aesthetics can be assigned to either:  

* **Static values** (`color = "yellow"`)  
  - Assigned *outside* `aes()`  
* **A data column** (`aes(fill = died)`)  
  - Assigned *inside* `aes()`
  - Displays data as "groups"  
  

For example, below, point shape will vary by outcome (the value in column `died`), but every point is colored yellow.   

```{r, eval=F, echo=T}
ggplot(data = linelist,
       mapping = aes(x = age, y = days_hosp))+
  geom_point(
    mapping = aes(shape = died),
    color = "yellow")
```

]


.pull-right[

Some examples:  

```{r, message=F, warning=F}

shape_3 <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(shape = 3)+
  theme_minimal()+
  labs(title = "shape = 3")

shape_died <- ggplot(data = linelist, aes(x = age, y = days_hosp))+
  geom_point(aes(shape = died))+
  theme_minimal()+
  labs(title = "aes(shape = died)")

###

fill_purple <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(fill = "purple")+
  theme_minimal()+
  labs(title = "fill = 'purple'")


fill_died <- ggplot(data = linelist, aes(x = date_onset))+
  geom_histogram(aes(fill = died))+
    theme_minimal()+
  labs(title = "aes(fill = died)")

###

col <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(fill = "lightgreen", color = "purple")+
  theme_minimal()+
  labs(title = "fill = 'lightgreen', color = 'purple'")


col_died <- ggplot(data = linelist %>% count(died), aes(x = died, y = n))+
  geom_col(aes(fill = died), color = "black")+
  theme_minimal()+
  labs(title = "aes(fill = died), color = 'black'")


cowplot::plot_grid(shape_3, shape_died,
                  fill_purple, fill_died,
                   col, col_died,
                   ncol = 2, rel_widths = c(2,2))


```

]







---
# Static aesthetics  

.pull-left[

An aesthetic is *static*, applying to all data points, if it is assigned to a number or character value and written *outside* `aes()`  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp))+ 
*geom_point(color = "seagreen")
```

Other examples:  
`size = 3`  
`transparency = 0.5`  
`width = 1.2`  

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
     x = age,
     y = days_hosp))+
geom_point(color = "seagreen")
```
] 






---
# Dynamic aesthetics   

.pull-left[

An aesthetic is *dynamic*, varying for each data point, if it assigned to a *column name* and written *inside* `aes()`    

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp))+   
geom_point(
* mapping = aes(color = died))
```

*Note: `color = died` could also be written in `ggplot()`'s `aes()`.*
]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age,
    y = days_hosp))+   
geom_point(
  mapping = aes(color = died))
```
]

???

In the next slide, the color = died will appear in the ggplot()'s aes() command for simplicity.
This works because there is only one geom and the geom_point will inherit the color mapping.  



---
# Multiple aesthetics - example  

.pull-left[

Both static and dynamic aesthetics: 

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)+
  geom_point(
    mapping = aes(
      x = age,
      y = days_hosp,
*     color = died),  # color varies by outcome
*   size = 3)         # all points 3x size
```


]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       size = 3)+
  geom_point()        
```
]

???

As there is only one geom, all aesthetics can be writtein `ggplot()`, or in `geom_point()`



---
# Scales - overview  

Scale commands control *how* the aesthetic mappings manifest, for example:  
* *Which* colors or shapes to display  
* The min/max of point sizes  
* The min/max and frequency of axes breaks  

To replace the defaults, add a `scale_` command. As a generic formula, these commands are written as `scale_AESTHETIC_METHOD()`.  

1) `scale_` : this prefix never changes  
2) Aesthetics like: `_fill_` , `_color_` , `_x_` , `_y_` , etc.  
3) Methods like: `_continuous()`, `_discrete()`, `_manual()`, `_date()` etc.

Inside the command, use arguments such as `breaks=`, `values=`, or `labels=` (there are many possibilities).  


---
# Scales examples  

Some examples of scale commands:  

You want to adjust  |Scale command
--------------------|-------------------
continuous y-axis   |`scale_y_continuous()`
date x-axis         |`scale_x_date()`  
categorical x-axis  |`scale_x_discrete()`  
fill, continuous    |`scale_fill_continuous()`
fill, continuous    |`scale_fill_gradient()`  
color, manual assign|`scale_color_manual()`  




---
# Scales - default 

.pull-left[

Here, the fill of a bar plot uses the **default colors and axis breaks**:  

```{r, eval=F, echo=T}
ggplot(linelist)+
  geom_bar(aes(x = eth_race, fill = died))
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+
  geom_bar(aes(x = eth_race, fill = died))+
  theme_gray(base_size = 18)
```

]



---
# Scales - adjusted fill 

.pull-left[

First, in a `scale_fill_manual()` we list the color assignments, in a vector `c()`.   

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
*scale_fill_manual(        
*  values = c("Yes"    = "violetred", 
*             "No"     = "aquamarine",
*            "Unknown" = "grey"))
  #na.value = "grey"  # for missing values, if applicable
```


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey"))+
theme_gray(base_size = 18)
```
]




---
# Scales - adjusted y-axis 

.pull-left[

Then, in `scale_y_continuous()` we adjust the y-axis breaks using `seq()` to define a numeric sequence.   

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey"))+
*scale_y_continuous(
*  breaks = seq(from = 0,
*               to = 35000,
*               by = 5000))
```


]

.pull-right[

```{r}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey"))+
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000))+
theme_gray(base_size = 18)
```

]





---
# Scales - "Floating plots" 

.pull-left[

In any `scale_x_` or `scale_y_` command, use `expand = c(0,0)` to remove excess space around the plot features.  

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes"    = "violetred", 
             "No"     = "aquamarine",
            "Unknown" = "grey"))+
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
* expand = c(0,0))+
*scale_x_discrete(
*  expand = c(0,0))
```


]

.pull-right[

```{r}
ggplot(linelist)+
geom_bar(aes(x = eth_race, fill = died))+
scale_fill_manual(        
  values = c("Yes" = "violetred", 
             "No" = "aquamarine",
            "Unknown" = "grey"))+
scale_y_continuous(
  breaks = seq(from = 0,
               to = 35000,
               by = 5000),
  expand = c(0,0))+
scale_x_discrete(
  expand = c(0,0))+
theme_grey(base_size = 18)
```

]




---
# Scales - date axis

.pull-left[
Default date axes can be adjusted with `scale_x_date()`, which offers special arguments `date_breaks=` and `date_labels=`.  

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))
```


]

.pull-right[

```{r}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
theme_grey(base_size = 18)

```

]







---
# Scales - date axis

.pull-left[
Specify break intervals to `date_breaks=` using values like "1 week", or "2 weeks", or "3 months" 

```{r, eval=F, echo=T}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
*scale_x_date(
*  date_breaks = "3 months")

```


]

.pull-right[

```{r}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
scale_x_date(
  date_breaks = "3 months"
)+
theme_grey(base_size = 18)

```

]




---
# Scales - date axis

.pull-left[
Specify date format to `date_labels=` using "strptime" syntax ([link](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/strptime)) like `"%d %b %Y"` for DD MMM YYYY.  


```{r, eval=F, echo=T}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
scale_x_date(
  date_breaks = "3 months",
* date_labels = "%d %b\n%Y")  # \n is a newline

```

See Epi R Handbook [Epicurves](https://epirhandbook.com/epidemic-curves.html) and [Strings](https://epirhandbook.com/characters-and-strings.html) pages for more tips

]

.pull-right[

```{r}
ggplot(linelist)+
geom_histogram(aes(x = date_onset))+
scale_x_date(
  date_breaks = "3 months",
  date_labels = "%d %b\n%Y"
)+
theme_grey(base_size = 18)

```

]





---
# Labels  

.pull-left[

Use `lab()` to edit title, subtitle, caption, axes labels, and legend title  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist)+
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3)+
*labs(
*  title = "Duration of admission among hospitalized COVID-19 patients",
*  x = "Age (years)",
*  y = "Duration (days)",
*  caption = "Fictional COVID-19 data",
*  color = "Deceased"
)
```

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist)+
geom_point(
  mapping = aes(
    x = age,
    y = days_hosp,
    color = died),    
  alpha = 0.3)+
labs(
  title = "Duration of admission among hospitalized COVID-19 patients",
  x = "Age (years)",
  y = "Duration (days)",
  caption = "Fictional COVID-19 data",
  color = "Deceased"
)+
theme_grey(base_size = 18)
```
]



---
# Label tips  

See the [Epi R Handbook page](https://epirhandbook.com/characters-and-strings.html#dynamic-strings) on adjusting characters with the **stringr** package

**New lines**  
Use `\n` within the string to bump to a new line, or place the text in [`str_wrap()`](https://stringr.tidyverse.org/reference/str_wrap.html) and specify the number of characters to wrap at.  

```{r, eval=F, echo=T}
title = str_wrap("This is a really long title", 30)
```

**Dynamic labels**  
Use `str_glue()` to imbed R code that updates with the data.  

```{r, eval=F, echo=T}
caption = str_glue("Data as of {Sys.Date()}"))
```

```{r, eval=F, echo=T}
caption = str_glue("{nrow(linelist %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

**Legend title**  
In `labs()`, write the aesthetic that created the legend, like `fill=`, `color=`, or `shape=`, and provide a title.  



???
Explain that in str_glue, anything within curly brackets it will run as R code.  


---
# Themes  

.pull-left[

Themes are non-data plot features (background, text side/color, etc).  

[These "complete themes"](https://ggplot2.tidyverse.org/reference/ggtheme.html) are easy to add.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
     title = "Duration of admission among hospitalized COVID-19 patients",
     x = "Age (years)",
     y = "Duration (days)",
     caption = "Fictional COVID-19 data",
     color = "Deceased")+
* theme_minimal(base_size = 18)
```

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "Duration of admission among hospitalized COVID-19 patients",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data",
    color = "Deceased")+
  theme_minimal(base_size = 18)
```
]

???
Others include theme_grey, theme_classic, etc... adjust base text size.







---
# Syntax - micro-adjust theme  

.pull-left[

Use `theme()` and [this list](https://ggplot2.tidyverse.org/reference/theme.html) of feature-specific arguments.  

```{r, echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(
    x = age, y = days_hosp, color = died),    
    alpha = 0.3)+
geom_point()+
labs(
  title = "Duration of admission among hospitalized COVID-19 patients",
  x = "Age (years)", y = "Duration (days)",
  caption = "Fictional COVID-19 data",
  color = "Deceased")+
theme_minimal(base_size = 14)+
*theme(
* legend.position = "bottom",
* plot.title = element_text(color = "red",
*                           face = "bold"),
* axis.title.y = element_text(angle = 90))
```

]

.pull-right[

```{r , echo = FALSE, eval = TRUE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x = age,
         y = days_hosp,
         color = died),    
       alpha = 0.3)+
  geom_point()+
  labs(
    title = "Duration of admission among hospitalized COVID-19 patients",
    x = "Age (years)",
    y = "Duration (days)",
    caption = "Fictional COVID-19 data",
    color = "Deceased")+
  theme_minimal(base_size = 18)+
  theme(
    legend.position = "bottom",
    plot.title = element_text(color = "red",
                              size = 20,
                              face = "bold"),
    axis.title.y = element_text(angle = 0))
```
]

???
Talk about these theme() arguments and how they consist of two parts, just like `mapping = aes()`. 
Explain that nobody has these all memorized, but the common ones are easy to remember once you use them enough.  





---
# Make an epicurve  

Two approaches that we suggest:  

1) Use the **incidence2** package  
  * Fast, simple, and modifiable with ggplot additions  
  
2) Use ggplot's `geom_histogram()`  
  * Most customizeability  
  * Most complex code  
  
See the Epi R handbook's [Epicurves page](https://epirhandbook.com/epidemic-curves.html) for details and common scenarios  







---
# Epicurve - make incidence object 

.pull-left[

Load **incidence2**  

```{r, echo=T, eval=F}
pacman::p_load(incidence2) # install/load
```

**Create** an incidence object from your dataset  

```{r, echo=T, eval=F}
weekly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "week")       # bin interval   
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(weekly)
```
]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
weekly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "week")       # bin interval   

plot(weekly)
```

]




---
# Epicurve - incidence object 

.pull-left[

Adjust the interval

```{r, echo=T, eval=F}
bimonthly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
*  interval = "2 months")  # bin interval   
```

**Plot** the incidence object  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
plot(bimonthly)
```

]

.pull-right[

```{r, echo=F, eval=T}
library(incidence2)
bimonthly <- incidence(
  x = linelist,            # define dataset
  date_index = date_onset, # date column
  interval = "2 months")       # bin interval   

plot(bimonthly)
```

]


---
# Epicurve - ggplot  

Since we have only one geom and one data frame linked to the plot, we could move the _mapping_ to the `geom_histogram()` call:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot() + 
  geom_histogram(
    data = linelist,
    mapping = aes(x = date_onset))
````
 

.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)  
  ) + 
  geom_histogram()
```
]






---
# Epicurve - ggplot  

.pull-left[

Use `geom_histogram()` with specified bins.   

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)  
) + #<<
  geom_histogram() #<<
```

--
Since we have only one geom and one data frame linked to the plot, we could move the _mapping_ to the `geom_histogram()` call:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot() + 
  geom_histogram(
    data = linelist,
    mapping = aes(x = date_onset))
````
] 

.pull-right[
```{r }
ggplot(
  data = linelist,
  mapping = aes(x = date_onset)  
  ) + 
  geom_histogram()
```
]





---
# Show groups  

So far the graph shows the distribution of cases in all hospitals. 

It would make sense to break down the visualization by hospitals.

Two options:  

* Fill each hospital in different color (stacked histogram)
* Create multiple plots, each showing a different hospital



---
# Color by group

.pull-left[

To color by group (stacked epicurve), we need to map the variable `eth_race` to the `fill=` aesthetic *in* the `aes()`:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(
         x    = date_onset,
         fill = eth_race))+ #<<
  geom_histogram()
```

Note: the _fill_ aesthetics control the color filling areas while the _color_ aesthetics control the color of lines and points.

] 

.pull-right[
```{r }
ggplot(data = linelist) +
  geom_histogram(
    mapping = aes(
      x = date_onset,
      fill = eth_race
      )
    )
```
]



---
# A common error  

.pull-left[

You have multiple data points per x-value, but forgot to separate out the groups

```{r, eval=F, echo = T}
linelist %>% 
  group_by(died,
           week_onset = lubridate::floor_date(date_onset, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_onset) %>% 

  ggplot(
    mapping = aes(
      x = week_onset,       
      y = n_cases)
    )+
  geom_line()+
  labs(title = "geom_line()")
```
]

.pull-right[

```{r, eval=T, echo=F}
linelist %>% 
  group_by(died,
           week_onset = lubridate::floor_date(date_onset, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_onset) %>% 

  ggplot(
    mapping = aes(
      x = week_onset,       
      y = n_cases)
    )+
  geom_line()+
  labs(title = "Weekly cases, by hospital (?)")


```
]



---
# A common error - resolved  

.pull-left[

You have multiple data points per x-value, but forgot to separate out the groups

```{r, eval=F, echo = T}
linelist %>% 
  group_by(died,
           week_onset = lubridate::floor_date(date_onset, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_onset) %>% 

  ggplot(
    mapping = aes(
      x = week_onset,       
      y = n_cases,
      color = died)   #<<
    )+
  geom_line()+
  labs(title = "geom_line()")
```
]

.pull-right[

```{r, eval=T, echo=F}
linelist %>% 
  group_by(died,
           week_onset = lubridate::floor_date(date_onset, "week")) %>% 
  summarise(n_cases = n()) %>% 
  drop_na(week_onset) %>% 
  
  ggplot(
    mapping = aes(
      x = week_onset,       
      y = n_cases,
      color = died)
    )+
  geom_line()+
  labs(title = "Weekly cases, by outcome")


```
]





---
# Facets/small-multiples


.pull-left[

To generate one graph by hospital:  

```{r , echo = TRUE, eval = FALSE, tidy = FALSE}
ggplot(data = linelist,
       mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_wrap(~eth_race) #<<
```

] 



.pull-right[
```{r }
ggplot(data = linelist,
       mapping = aes(x = date_onset)) +
  geom_histogram() +
  facet_wrap(~ eth_race)
```

]





---
# Bar plots  

`geom_col()` and `geom_bar()` are used to make general bar plots (non-epicurves).

Use `geom_bar()` if bar height should reflect the number of rows in the data (e.g. a case linelist).  

```{r, echo=T, eval=F}
ggplot(linelist)+            # begin with linelist       
*  geom_bar(
     mapping = aes(x = eth_race)) # one bar per race/ethnicity. No y= argument. 
```

Use `geom_col()` if the data have a numeric column containing the desired bar height (i.e. aggregated count data).  

```{r, eval=F, echo=T}
ggplot(linelist_agg)+    # begin with aggregated count data            
*  geom_col(
    mapping = aes(x = eth_race, y = n))   # bar height is value in column "n"
```


---

class: medium-table

# Bar plot (linelist data)  

.pull-left[

With `geom_bar()`, the height reflects the number of rows per x-axis group.  

```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist)+             
  geom_bar(                 # column height by number of rows
    mapping = aes(x = eth_race)) # one bar per race/ethnicity. No y= argument. 
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(                 # column height by number of rows
    mapping = aes(x = eth_race)) # one bar per race/ethnicity. No y= argument. 
```
]

---

class: medium-table

# Bar plot - linelist (grouped)  

.pull-left[

To achieve "stacked" bars with `geom_bar()`, simply assign the group column to `fill =` within `aes()`
```{r, eval=T, echo=F}
linelist %>% 
  select(date_onset, eth_race, died) %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist)+             
  geom_bar(           # column height by number of rows
    mapping = aes(
      x = eth_race,        # one bar per ethnicity. No y= argument.
      fill = died))   # stack bars by column "died" 
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(           # column height by number of rows
    mapping = aes(
      x = eth_race,        # one bar per ethnicity. No y= argument.
      fill = died))   # stack bars by column "died"  
```
]



---

class: medium-table

# Bar plot - counts  

.pull-left[

In contrast, `geom_col()` uses a column of counts in the data, such as column `n` in this `linelist_eth` dataset:

```{r, eval=T, echo=F}
linelist_eth <- linelist %>% 
  count(eth_race)

linelist_eth %>% 
  head(6) %>% 
  knitr::kable()
```

```{r, echo=T, eval=F}
ggplot(linelist_eth)+             
*  geom_col(         # column height by numeric value
    mapping = aes(   
      x = eth_race,       # one bar per ethnicity.
*     y = n))        # y= column specifies bar height    
```


Column `n` is assigned to the `y=` argument to provide the bar height.    

```{r, echo=F, eval=T}
ggplot(linelist_eth)+             
  geom_col(         # column height by numeric value
    mapping = aes(   
      x = eth_race,       # one bar per ethnicity.
      y = n))        # y= column specifies bar height   
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,           # one bar per ethnicity. No y= argument. 
      fill = died        # divide into stacked bars by outcome
    )
  )
```


]



---

class: medium-table

# Bar plot - counts (stacked)  

.pull-left[

To have "stacked" bars using `geom_col()`, each plotting group must have its own rows in the data. Use "long"-style like below:  

```{r, echo = F, eval=T}
linelist_eth_died <- linelist %>% 
  count(eth_race, died)

linelist_eth_died %>% 
  head(6) %>% 
  knitr::kable()
```

]

.pull-right[

```{r, echo=F, eval=T}
ggplot(linelist_eth_died)+ # begin with data aggregated by day/ethnicity              
  geom_col(               # column height by aggregated counts
    mapping = aes(
      x = eth_race,            # one bar per ethnicity. 
      y = n,              # bar height from column "n"
      fill = died))       # stacked bars by outcome
```

]


---
# Bar plot - a common error 

.pull-left[

If your data look like this (counts) and your plot looks like that (bars of same height), ensure you are using `geom_col()` and not `geom_bar()`!  

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  knitr::kable()
```

]

.pull-right[

```{r, echo=F, eval=T}
linelist %>% 
  count(eth_race) %>% 
  ggplot()+
  geom_bar(
    mapping = aes(x = eth_race))
```

]




---
# Bar plots (flip axes)  

.pull-left[

It is simple to flip the axes on any ggplot by adding `coord_flip()`  


```{r, echo=T, eval=F}
ggplot(linelist)+        # begin with case linelist    
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,           # one bar per ethnicity. No y= argument. 
      fill = died))+     # stacked bars by outcome
* coord_flip()           # flip x and y axes
```


]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,           # one bar per ethnicity. No y= argument. 
      fill = died))+     # divide into stacked bars by outcome
  coord_flip()           # flip x and y axes
```
]


---
# Bar plots (adjust order)  

.pull-left[

Use functions from the **forcats** package to convert the column to class *factor* and adjust the "levels".  

Changes can be made outside ggplot (a lasting change to the dataset), or inside (applies only to this plot).  

[1] See the Epi R Handbook page on [factors](https://epirhandbook.com/factors.html#within-a-plot). 

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = eth_race,           # one bar per ethnicity. No y= argument. 
      fill = died))+     # divide into stacked bars by outcome
  coord_flip()           # flip x and y axes
```
]






---
# Bar plots (adjust order)  

.pull-left[

Below, to order by frequency, `fct_infreq()` is applied to the x-axis column `eth_race` and the fill column `died`.

```{r, echo=T, eval=F}
ggplot(linelist)+          # begin with case linelist    
  geom_bar(                # column height by number of rows
    mapping = aes(
*     x = fct_infreq(eth_race), # one bar per ethnicity. No y= argument. 
*     fill = fct_infreq(died)))+       # stacked bars by outcome
 coord_flip()              # flip x and y axes
```

]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = fct_infreq(eth_race),           # one bar per ethnicity. No y= argument. 
      fill = fct_infreq(died)))+     # divide into stacked bars by outcome
  coord_flip()           # flip x and y axes
```
]




---
# Bar plots (reverse order)  

.pull-left[

To *reverse* bar order, use `fct_rev()` from the **forcats** package. it can be wrapped around other functions. 

The below reverse the previous frequency ordering from `fct_infreq()`.  


```{r, echo=F, eval=F}
ggplot(linelist)+              
  geom_bar(                
    mapping = aes(
*     x = fct_rev(fct_infreq(eth_race)),  # ordered in reverse frequency
*     fill = fct_rev(fct_infreq(died))))+       
 coord_flip()              
```

[1] See the Epi R Handbook page on [factors](https://epirhandbook.com/factors.html#within-a-plot). 
]

.pull-right[

```{r, eval=T, echo=F}
ggplot(linelist)+             
  geom_bar(              # column height by number of rows
    mapping = aes(
      x = fct_rev(fct_infreq(eth_race)),            
      fill = fct_rev(fct_infreq(died))))+     
  coord_flip()          
```

]

---

# Labeling  

Aggregate zip codes into number of cases and number of deaths


---

# Final slide

